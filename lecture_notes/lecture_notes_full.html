<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Untitled Document.md</title><style>@import 'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.2.0/katex.min.css';code{color:#c7254e;background-color:#f9f2f4;border-radius:4px}code,kbd{padding:2px 4px}kbd{color:#fff;background-color:#333;border-radius:3px;box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;box-shadow:none}pre{display:block;margin:0 0 10px;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}table{background-color:transparent}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>thead>tr>th{padding:8px;line-height:1.4285714;border-top:1px solid #ddd}.table>thead>tr>td,.table>tbody>tr>th,.table>tbody>tr>td,.table>tfoot>tr>th,.table>tfoot>tr>td{padding:8px;line-height:1.4285714;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>th,.table>thead:first-child>tr:first-child>td{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>thead>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>tfoot>tr>td{padding:5px}.table-bordered,.table-bordered>thead>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>tfoot>tr>td{border:1px solid #ddd}.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px}.table-striped>tbody>tr:nth-child(odd)>td,.table-striped>tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover>tbody>tr:hover>td,.table-hover>tbody>tr:hover>th{background-color:#f5f5f5}table col[class*="col-"]{position:static;float:none;display:table-column}table td[class*="col-"],table th[class*="col-"]{position:static;float:none;display:table-cell}.table>thead>tr>td.active,.table>thead>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th{background-color:#f5f5f5}.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover,.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr.active:hover>th{background-color:#e8e8e8}.table>thead>tr>td.success,.table>thead>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th{background-color:#dff0d8}.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr.success:hover>th{background-color:#d0e9c6}.table>thead>tr>td.info,.table>thead>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th{background-color:#d9edf7}.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover,.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr.info:hover>th{background-color:#c4e3f3}.table>thead>tr>td.warning,.table>thead>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th{background-color:#fcf8e3}.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr.warning:hover>th{background-color:#faf2cc}.table>thead>tr>td.danger,.table>thead>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th{background-color:#f2dede}.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr.danger:hover>th{background-color:#ebcccc}fieldset{border:0;min-width:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type="file"]{display:block}input[type="range"]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{padding-top:7px}output,.form-control{display:block;font-size:14px;line-height:1.4285714;color:#555}.form-control{width:100%;height:34px;padding:6px 12px;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#777;opacity:1}.form-control:-ms-input-placeholder{color:#777}.form-control::-webkit-input-placeholder{color:#777}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{cursor:not-allowed;background-color:#eee;opacity:1}textarea.form-control{height:auto}input[type="date"],input[type="time"],input[type="datetime-local"],input[type="month"]{line-height:34px;line-height:1.4285714 \0}input[type="date"].input-sm,.form-horizontal .form-group-sm input[type="date"].form-control,.input-group-sm>input[type="date"].form-control,.input-group-sm>input[type="date"].input-group-addon,.input-group-sm>.input-group-btn>input[type="date"].btn,input[type="time"].input-sm,.form-horizontal .form-group-sm input[type="time"].form-control,.input-group-sm>input[type="time"].form-control,.input-group-sm>input[type="time"].input-group-addon,.input-group-sm>.input-group-btn>input[type="time"].btn,input[type="datetime-local"].input-sm,.form-horizontal .form-group-sm input[type="datetime-local"].form-control,.input-group-sm>input[type="datetime-local"].form-control,.input-group-sm>input[type="datetime-local"].input-group-addon,.input-group-sm>.input-group-btn>input[type="datetime-local"].btn,input[type="month"].input-sm,.form-horizontal .form-group-sm input[type="month"].form-control,.input-group-sm>input[type="month"].form-control,.input-group-sm>input[type="month"].input-group-addon,.input-group-sm>.input-group-btn>input[type="month"].btn{line-height:30px}input[type="date"].input-lg,.form-horizontal .form-group-lg input[type="date"].form-control,.input-group-lg>input[type="date"].form-control,.input-group-lg>input[type="date"].input-group-addon,.input-group-lg>.input-group-btn>input[type="date"].btn,input[type="time"].input-lg,.form-horizontal .form-group-lg input[type="time"].form-control,.input-group-lg>input[type="time"].form-control,.input-group-lg>input[type="time"].input-group-addon,.input-group-lg>.input-group-btn>input[type="time"].btn,input[type="datetime-local"].input-lg,.form-horizontal .form-group-lg input[type="datetime-local"].form-control,.input-group-lg>input[type="datetime-local"].form-control,.input-group-lg>input[type="datetime-local"].input-group-addon,.input-group-lg>.input-group-btn>input[type="datetime-local"].btn,input[type="month"].input-lg,.form-horizontal .form-group-lg input[type="month"].form-control,.input-group-lg>input[type="month"].form-control,.input-group-lg>input[type="month"].input-group-addon,.input-group-lg>.input-group-btn>input[type="month"].btn{line-height:46px}.form-group{margin-bottom:15px}.radio,.checkbox{position:relative;display:block;min-height:20px;margin-top:10px;margin-bottom:10px}.radio label,.checkbox label{padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{position:absolute;margin-left:-20px;margin-top:4px \9}.radio+.radio,.checkbox+.checkbox{margin-top:-5px}.radio-inline,.checkbox-inline{display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:400;cursor:pointer}.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px}input[type="radio"][disabled],input[type="radio"].disabled,fieldset[disabled] input[type="radio"],input[type="checkbox"][disabled],input[type="checkbox"].disabled,fieldset[disabled] input[type="checkbox"],.radio-inline.disabled,fieldset[disabled] .radio-inline,.checkbox-inline.disabled,fieldset[disabled] .checkbox-inline,.radio.disabled label,fieldset[disabled] .radio label,.checkbox.disabled label,fieldset[disabled] .checkbox label{cursor:not-allowed}.form-control-static{padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-horizontal .form-group-lg .form-control-static.form-control,.input-group-lg>.form-control-static.form-control,.input-group-lg>.form-control-static.input-group-addon,.input-group-lg>.input-group-btn>.form-control-static.btn,.form-control-static.input-sm,.form-horizontal .form-group-sm .form-control-static.form-control,.input-group-sm>.form-control-static.form-control,.input-group-sm>.form-control-static.input-group-addon,.input-group-sm>.input-group-btn>.form-control-static.btn{padding-left:0;padding-right:0}.input-sm,.form-horizontal .form-group-sm .form-control,.input-group-sm>.form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.input-group-sm>.input-group-addon{height:30px;line-height:1.5}.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm,.form-horizontal .form-group-sm select.form-control,.input-group-sm>select.form-control,.input-group-sm>select.input-group-addon,.input-group-sm>.input-group-btn>select.btn{height:30px;line-height:30px}textarea.input-sm,.form-horizontal .form-group-sm textarea.form-control,.input-group-sm>textarea.form-control,.input-group-sm>textarea.input-group-addon,.input-group-sm>.input-group-btn>textarea.btn,select[multiple].input-sm,.form-horizontal .form-group-sm select[multiple].form-control,.input-group-sm>select[multiple].form-control,.input-group-sm>select[multiple].input-group-addon,.input-group-sm>.input-group-btn>select[multiple].btn{height:auto}.input-lg,.form-horizontal .form-group-lg .form-control,.input-group-lg>.form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.input-group-lg>.input-group-addon{height:46px;line-height:1.33}.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}select.input-lg,.form-horizontal .form-group-lg select.form-control,.input-group-lg>select.form-control,.input-group-lg>select.input-group-addon,.input-group-lg>.input-group-btn>select.btn{height:46px;line-height:46px}textarea.input-lg,.form-horizontal .form-group-lg textarea.form-control,.input-group-lg>textarea.form-control,.input-group-lg>textarea.input-group-addon,.input-group-lg>.input-group-btn>textarea.btn,select[multiple].input-lg,.form-horizontal .form-group-lg select[multiple].form-control,.input-group-lg>select[multiple].form-control,.input-group-lg>select[multiple].input-group-addon,.input-group-lg>.input-group-btn>select[multiple].btn{height:auto}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:25px;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center}.input-lg+.form-control-feedback,.form-horizontal .form-group-lg .form-control+.form-control-feedback,.input-group-lg>.form-control+.form-control-feedback,.input-group-lg>.input-group-addon+.form-control-feedback,.input-group-lg>.input-group-btn>.btn+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback,.form-horizontal .form-group-sm .form-control+.form-control-feedback,.input-group-sm>.form-control+.form-control-feedback,.input-group-sm>.input-group-addon+.form-control-feedback,.input-group-sm>.input-group-btn>.btn+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline{color:#3c763d}.has-success .form-control{border-color:#3c763d;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;border-color:#3c763d;background-color:#dff0d8}.has-success .form-control-feedback{color:#3c763d}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;border-color:#8a6d3b;background-color:#fcf8e3}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline{color:#a94442}.has-error .form-control{border-color:#a94442;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;border-color:#a94442;background-color:#f2dede}.has-error .form-control-feedback{color:#a94442}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:7px}.form-horizontal .radio,.form-horizontal .checkbox{min-height:27px}.form-horizontal .form-group{margin-left:-15px;margin-right:-15px}.form-horizontal .form-group:before{content:" ";display:table}.form-horizontal .form-group:after{content:" ";display:table;clear:both}.form-horizontal .has-feedback .form-control-feedback{top:0;right:15px}.btn{display:inline-block;vertical-align:middle;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;pointer-events:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{background-image:none}.btn-default.disabled,.btn-default.disabled:hover,.btn-default.disabled:focus,.btn-default.disabled:active,.btn-default.disabled.active,.btn-default[disabled],.btn-default[disabled]:hover,.btn-default[disabled]:focus,.btn-default[disabled]:active,.btn-default[disabled].active,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default:hover,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default.active{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#428bca;border-color:#357ebd}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{color:#fff;background-color:#3071a9;border-color:#285e8e}.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{background-image:none}.btn-primary.disabled,.btn-primary.disabled:hover,.btn-primary.disabled:focus,.btn-primary.disabled:active,.btn-primary.disabled.active,.btn-primary[disabled],.btn-primary[disabled]:hover,.btn-primary[disabled]:focus,.btn-primary[disabled]:active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary:hover,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary.active{background-color:#428bca;border-color:#357ebd}.btn-primary .badge{color:#428bca;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{background-image:none}.btn-success.disabled,.btn-success.disabled:hover,.btn-success.disabled:focus,.btn-success.disabled:active,.btn-success.disabled.active,.btn-success[disabled],.btn-success[disabled]:hover,.btn-success[disabled]:focus,.btn-success[disabled]:active,.btn-success[disabled].active,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success:hover,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success.active{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{background-image:none}.btn-info.disabled,.btn-info.disabled:hover,.btn-info.disabled:focus,.btn-info.disabled:active,.btn-info.disabled.active,.btn-info[disabled],.btn-info[disabled]:hover,.btn-info[disabled]:focus,.btn-info[disabled]:active,.btn-info[disabled].active,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info:hover,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info.active{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{background-image:none}.btn-warning.disabled,.btn-warning.disabled:hover,.btn-warning.disabled:focus,.btn-warning.disabled:active,.btn-warning.disabled.active,.btn-warning[disabled],.btn-warning[disabled]:hover,.btn-warning[disabled]:focus,.btn-warning[disabled]:active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning:hover,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning.active{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{background-image:none}.btn-danger.disabled,.btn-danger.disabled:hover,.btn-danger.disabled:focus,.btn-danger.disabled:active,.btn-danger.disabled.active,.btn-danger[disabled],.btn-danger[disabled]:hover,.btn-danger[disabled]:focus,.btn-danger[disabled]:active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger:hover,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger.active{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#428bca;font-weight:400;cursor:pointer;border-radius:0}.btn-link,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#2a6496;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:hover,fieldset[disabled] .btn-link:focus{color:#777;text-decoration:none}.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.btn-sm{padding:5px 10px}.btn-sm,.btn-xs{font-size:12px;line-height:1.5;border-radius:3px}.btn-xs{padding:1px 5px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;transition:height .35s ease}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*="col-"]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-addon,.input-group-btn,.input-group .form-control{display:table-cell}.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child),.input-group .form-control:not(:first-child):not(:last-child){border-radius:0}.input-group-addon{white-space:nowrap}.input-group-addon,.input-group-btn{width:1%;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm,.form-horizontal .form-group-sm .input-group-addon.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.input-group-addon.btn{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg,.form-horizontal .form-group-lg .input-group-addon.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.input-group-addon.btn{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type="radio"],.input-group-addon input[type="checkbox"]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child>.btn-group:not(:last-child)>.btn{border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:first-child>.btn-group:not(:first-child)>.btn{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{font-size:0;white-space:nowrap}.input-group-btn,.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:hover,.input-group-btn>.btn:focus,.input-group-btn>.btn:active{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;line-height:1.4285714;text-decoration:none;color:#428bca;background-color:#fff;border:1px solid #ddd;margin-left:-1px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-bottom-left-radius:4px;border-top-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-bottom-right-radius:4px;border-top-right-radius:4px}.pagination>li>a:hover,.pagination>li>a:focus,.pagination>li>span:hover,.pagination>li>span:focus{color:#2a6496;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:hover,.pagination>.active>a:focus,.pagination>.active>span,.pagination>.active>span:hover,.pagination>.active>span:focus{z-index:2;color:#fff;background-color:#428bca;border-color:#428bca;cursor:default}.pagination>.disabled>span,.pagination>.disabled>span:hover,.pagination>.disabled>span:focus,.pagination>.disabled>a,.pagination>.disabled>a:hover,.pagination>.disabled>a:focus{color:#777;background-color:#fff;border-color:#ddd;cursor:not-allowed}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-bottom-left-radius:6px;border-top-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-bottom-right-radius:6px;border-top-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-bottom-left-radius:3px;border-top-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-bottom-right-radius:3px;border-top-right-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.modal-open,.modal{overflow:hidden}.modal{display:none;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transform:translate3d(0,-25%,0);transform:translate3d(0,-25%,0);-webkit-transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out}.modal.in .modal-dialog{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 3px 9px rgba(0,0,0,.5);background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5;min-height:16.4285714px}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.4285714}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer:before,.modal-footer:after{content:" ";display:table}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important;visibility:hidden!important}.affix{position:fixed;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.hljs{display:block;overflow-x:auto;padding:.5em;background:#002b36;color:#839496;-webkit-text-size-adjust:none}.hljs-comment,.hljs-template_comment,.diff .hljs-header,.hljs-doctype,.hljs-pi,.lisp .hljs-string,.hljs-javadoc{color:#586e75}.hljs-keyword,.hljs-winutils,.method,.hljs-addition,.css .hljs-tag,.hljs-request,.hljs-status,.nginx .hljs-title{color:#859900}.hljs-number,.hljs-command,.hljs-string,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.tex .hljs-formula,.hljs-regexp,.hljs-hexcolor,.hljs-link_url{color:#2aa198}.hljs-title,.hljs-localvars,.hljs-chunk,.hljs-decorator,.hljs-built_in,.hljs-identifier,.vhdl .hljs-literal,.hljs-id,.css .hljs-function{color:#268bd2}.hljs-attribute,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number,.hljs-constant,.hljs-class .hljs-title,.hljs-parent,.hljs-type,.hljs-link_reference{color:#b58900}.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-pragma,.hljs-shebang,.hljs-symbol,.hljs-symbol .hljs-string,.diff .hljs-change,.hljs-special,.hljs-attr_selector,.hljs-subst,.hljs-cdata,.css .hljs-pseudo,.hljs-header{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#073642}*,*:before,*:after{box-sizing:border-box}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}images{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd{font-size:1em}code,kbd,pre,samp{font-family:monospace,monospace}samp{font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}.debug{background-color:#ffc0cb!important}.ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ir{background-color:transparent;border:0;overflow:hidden}.ir::before{content:'';display:block;height:150%;width:0}html{font-size:.875em;background:#fff;color:#373D49}html,body{font-family:Georgia,Cambria,serif;height:100%}body{font-size:1rem;font-weight:400;line-height:2rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}li{-webkit-font-feature-settings:'kern' 1,'onum' 1,'liga' 1;font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-left:1rem}li>ul,li>ol{margin-bottom:0}p{padding-top:.66001rem;-webkit-font-feature-settings:'kern' 1,'onum' 1,'liga' 1;font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-top:0}p,pre{margin-bottom:1.33999rem}pre{font-size:1rem;padding:.66001rem 9.5px 9.5px;line-height:2rem;background:-webkit-linear-gradient(top,#fff 0,#fff .75rem,#f5f7fa .75rem,#f5f7fa 2.75rem,#fff 2.75rem,#fff 4rem);background:linear-gradient(to bottom,#fff 0,#fff .75rem,#f5f7fa .75rem,#f5f7fa 2.75rem,#fff 2.75rem,#fff 4rem);background-size:100% 4rem;border-color:#D3DAEA}blockquote{margin:0}blockquote p{font-size:1rem;margin-bottom:.33999rem;font-style:italic;padding:.66001rem 1rem 1rem;border-left:3px solid #A0AABF}th,td{padding:12px}h1,h2,h3,h4,h5,h6{font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;-webkit-font-feature-settings:'dlig' 1,'liga' 1,'lnum' 1,'kern' 1;font-feature-settings:'dlig' 1,'liga' 1,'lnum' 1,'kern' 1;font-style:normal;font-weight:600;margin-top:0}h1{line-height:3rem;font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h2,h3{line-height:3rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}a{cursor:pointer;color:#35D7BB;text-decoration:none}a:hover,a:focus{border-bottom-color:#35D7BB;color:#dff9f4}img{height:auto;max-width:100%}.g{display:block}.g:after{clear:both;content:'';display:table}.g-b{float:left;margin:0;width:100%}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--center{display:block;float:none;margin:0 auto}.g-b--right{float:right}.g-b--1of1{width:100%}.g-b--1of2,.g-b--2of4,.g-b--3of6,.g-b--4of8,.g-b--5of10,.g-b--6of12{width:50%}.g-b--1of3,.g-b--2of6,.g-b--4of12{width:33.333%}.g-b--2of3,.g-b--4of6,.g-b--8of12{width:66.666%}.g-b--1of4,.g-b--2of8,.g-b--3of12{width:25%}.g-b--3of4,.g-b--6of8,.g-b--9of12{width:75%}.g-b--1of5,.g-b--2of10{width:20%}.g-b--2of5,.g-b--4of10{width:40%}.g-b--3of5,.g-b--6of10{width:60%}.g-b--4of5,.g-b--8of10{width:80%}.g-b--1of6,.g-b--2of12{width:16.666%}.g-b--5of6,.g-b--10of12{width:83.333%}.g-b--1of8{width:12.5%}.g-b--3of8{width:37.5%}.g-b--5of8{width:62.5%}.g-b--7of8{width:87.5%}.g-b--1of10{width:10%}.g-b--3of10{width:30%}.g-b--7of10{width:70%}.g-b--9of10{width:90%}.g-b--1of12{width:8.333%}.g-b--5of12{width:41.666%}.g-b--7of12{width:58.333%}.g-b--11of12{width:91.666%}.g-b--push--1of1{margin-left:100%}.g-b--push--1of2,.g-b--push--2of4,.g-b--push--3of6,.g-b--push--4of8,.g-b--push--5of10,.g-b--push--6of12{margin-left:50%}.g-b--push--1of3,.g-b--push--2of6,.g-b--push--4of12{margin-left:33.333%}.g-b--push--2of3,.g-b--push--4of6,.g-b--push--8of12{margin-left:66.666%}.g-b--push--1of4,.g-b--push--2of8,.g-b--push--3of12{margin-left:25%}.g-b--push--3of4,.g-b--push--6of8,.g-b--push--9of12{margin-left:75%}.g-b--push--1of5,.g-b--push--2of10{margin-left:20%}.g-b--push--2of5,.g-b--push--4of10{margin-left:40%}.g-b--push--3of5,.g-b--push--6of10{margin-left:60%}.g-b--push--4of5,.g-b--push--8of10{margin-left:80%}.g-b--push--1of6,.g-b--push--2of12{margin-left:16.666%}.g-b--push--5of6,.g-b--push--10of12{margin-left:83.333%}.g-b--push--1of8{margin-left:12.5%}.g-b--push--3of8{margin-left:37.5%}.g-b--push--5of8{margin-left:62.5%}.g-b--push--7of8{margin-left:87.5%}.g-b--push--1of10{margin-left:10%}.g-b--push--3of10{margin-left:30%}.g-b--push--7of10{margin-left:70%}.g-b--push--9of10{margin-left:90%}.g-b--push--1of12{margin-left:8.333%}.g-b--push--5of12{margin-left:41.666%}.g-b--push--7of12{margin-left:58.333%}.g-b--push--11of12{margin-left:91.666%}.g-b--pull--1of1{margin-right:100%}.g-b--pull--1of2,.g-b--pull--2of4,.g-b--pull--3of6,.g-b--pull--4of8,.g-b--pull--5of10,.g-b--pull--6of12{margin-right:50%}.g-b--pull--1of3,.g-b--pull--2of6,.g-b--pull--4of12{margin-right:33.333%}.g-b--pull--2of3,.g-b--pull--4of6,.g-b--pull--8of12{margin-right:66.666%}.g-b--pull--1of4,.g-b--pull--2of8,.g-b--pull--3of12{margin-right:25%}.g-b--pull--3of4,.g-b--pull--6of8,.g-b--pull--9of12{margin-right:75%}.g-b--pull--1of5,.g-b--pull--2of10{margin-right:20%}.g-b--pull--2of5,.g-b--pull--4of10{margin-right:40%}.g-b--pull--3of5,.g-b--pull--6of10{margin-right:60%}.g-b--pull--4of5,.g-b--pull--8of10{margin-right:80%}.g-b--pull--1of6,.g-b--pull--2of12{margin-right:16.666%}.g-b--pull--5of6,.g-b--pull--10of12{margin-right:83.333%}.g-b--pull--1of8{margin-right:12.5%}.g-b--pull--3of8{margin-right:37.5%}.g-b--pull--5of8{margin-right:62.5%}.g-b--pull--7of8{margin-right:87.5%}.g-b--pull--1of10{margin-right:10%}.g-b--pull--3of10{margin-right:30%}.g-b--pull--7of10{margin-right:70%}.g-b--pull--9of10{margin-right:90%}.g-b--pull--1of12{margin-right:8.333%}.g-b--pull--5of12{margin-right:41.666%}.g-b--pull--7of12{margin-right:58.333%}.g-b--pull--11of12{margin-right:91.666%}.splashscreen{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#373D49;z-index:22}.splashscreen-dillinger{width:260px;height:auto;display:block;margin:0 auto;padding-bottom:3rem}.splashscreen p{font-size:1.25rem;padding-top:.56251rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;text-align:center;max-width:500px;margin:0 auto;color:#FFF}.sp-center{position:relative;-webkit-transform:translateY(-50%);transform:translateY(-50%);top:50%}.open-menu>.wrapper{overflow-x:hidden}.page{margin:0 auto;position:relative;top:0;left:0;width:100%;height:100%;z-index:2;-webkit-transition:all .25s ease-in-out;transition:all .25s ease-in-out;background-color:#fff;padding-top:51px;will-change:left}.open-menu .page{left:270px}.title{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;color:#A0AABF;letter-spacing:1px;text-transform:uppercase;padding-left:16px;padding-right:16px;margin-top:1rem}.split-preview .title{padding-left:0}.title-document{line-height:1rem;font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem;font-weight:400;font-family:"Ubuntu Mono",Monaco;color:#373D49;padding-left:16px;padding-right:16px;width:80%;min-width:300px;outline:0;border:none}.icon{display:block;margin:0 auto;width:36px;height:36px;border-radius:3px;text-align:center}.icon svg{display:inline-block;margin-left:auto;margin-right:auto}.icon-preview{background-color:#373D49;line-height:40px}.icon-preview svg{width:19px;height:12px}.icon-settings{background-color:#373D49;line-height:44px}.icon-settings svg{width:18px;height:18px}.icon-link{width:16px;height:16px;line-height:1;margin-right:24px;text-align:right}.navbar{background-color:#373D49;height:51px;width:100%;position:fixed;top:0;left:0;z-index:6;-webkit-transition:all .25s ease-in-out;transition:all .25s ease-in-out;will-change:left}.navbar:after{content:"";display:table;clear:both}.open-menu .navbar{left:270px}.navbar-brand{float:left;margin:0 0 0 24px;padding:0;line-height:42px}.navbar-brand svg{width:85px;height:11px}.nav-left{float:left}.nav-right{float:right}.nav-sidebar{width:100%}.menu{list-style:none;margin:0;padding:0}.menu a{border:0;color:#A0AABF;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;outline:none;text-transform:uppercase}.menu a:hover{color:#35D7BB}.menu .menu-item{border:0;display:none;float:left;margin:0;position:relative}.menu .menu-item>a{display:block;font-size:12px;height:51px;letter-spacing:1px;line-height:51px;padding:0 24px}.menu .menu-item--settings,.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar,.menu .menu-item--link-unlink.in-sidebar,.menu .menu-item--documents.in-sidebar{display:block}.menu .menu-item--documents{padding-bottom:1rem}.menu .menu-item.open>a{background-color:#1D212A}.menu .menu-item-icon>a{height:auto;padding:0}.menu .menu-item-icon:hover>a{background-color:transparent}.menu .menu-link.open i{background-color:#1D212A}.menu .menu-link.open g{fill:#35D7BB}.menu .menu-link-preview,.menu .menu-link-settings{margin-top:8px;width:51px}.menu-sidebar{width:100%}.menu-sidebar .menu-item{float:none;margin-bottom:1px;width:100%}.menu-sidebar .menu-item.open>a{background-color:#373D49}.menu-sidebar .open .caret{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.menu-sidebar>.menu-item:hover .dropdown a,.menu-sidebar>.menu-item:hover .settings a{background-color:transparent}.menu-sidebar .menu-link{background-color:#373D49;font-weight:600}.menu-sidebar .menu-link:after{content:"";display:table;clear:both}.menu-sidebar .menu-link>span{float:left}.menu-sidebar .menu-link>.caret{float:right;text-align:right;top:22px}.menu-sidebar .dropdown,.menu-sidebar .settings{background-color:transparent;position:static;width:100%}.dropdown{position:absolute;right:0;top:51px;width:188px}.dropdown,.settings{display:none;background-color:#1D212A}.dropdown{padding:0}.dropdown,.settings,.sidebar-list{list-style:none;margin:0}.sidebar-list{padding:0}.dropdown li{margin:32px 0;padding:0 0 0 32px}.dropdown li,.settings li{line-height:1}.sidebar-list li{line-height:1;margin:32px 0;padding:0 0 0 32px}.dropdown a{color:#D0D6E2}.dropdown a,.settings a,.sidebar-list a{display:block;text-transform:none}.sidebar-list a{color:#D0D6E2}.dropdown a:after,.settings a:after,.sidebar-list a:after{content:"";display:table;clear:both}.dropdown .icon,.settings .icon,.sidebar-list .icon{float:right}.open .dropdown,.open .settings,.open .sidebar-list{display:block}.open .dropdown.collapse,.open .collapse.settings,.open .sidebar-list.collapse{display:none}.open .dropdown.collapse.in,.open .collapse.in.settings,.open .sidebar-list.collapse.in{display:block}.dropdown .unlinked .icon,.settings .unlinked .icon,.sidebar-list .unlinked .icon{opacity:.3}.dropdown.documents li,.documents.settings li,.sidebar-list.documents li{background-image:url("../img/icons/file.svg");background-position:240px center;background-repeat:no-repeat;background-size:14px 16px;padding:3px 32px}.dropdown.documents li.octocat,.documents.settings li.octocat,.sidebar-list.documents li.octocat{background-image:url("../img/icons/octocat.svg");background-position:234px center;background-size:24px 24px}.dropdown.documents li:last-child,.documents.settings li:last-child,.sidebar-list.documents li:last-child{margin-bottom:1rem}.dropdown.documents li.active a,.documents.settings li.active a,.sidebar-list.documents li.active a{color:#35D7BB}.settings{position:fixed;top:67px;right:16px;border-radius:3px;width:288px;background-color:#373D49;padding:16px;z-index:7}.show-settings .settings{display:block}.settings .has-checkbox{float:left}.settings a{font-size:1.25rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;-webkit-font-smoothing:antialiased;line-height:28px;color:#D0D6E2}.settings a:after{content:"";display:table;clear:both}.settings a:hover{color:#35D7BB}.settings li{border-bottom:1px solid #4F535B;margin:0;padding:16px 0}.settings li:last-child{border-bottom:none}.brand{border:none;display:block}.brand:hover g{fill:#35D7BB}.toggle{display:block;float:left;height:16px;padding:25px 16px 26px;width:40px}.toggle span:after,.toggle span:before{content:'';left:0;position:absolute;top:-6px}.toggle span:after{top:6px}.toggle span{display:block;position:relative}.toggle span,.toggle span:after,.toggle span:before{-webkit-backface-visibility:hidden;backface-visibility:hidden;background-color:#D3DAEA;height:2px;-webkit-transition:all .3s;transition:all .3s;width:20px}.open-menu .toggle span{background-color:transparent}.open-menu .toggle span:before{-webkit-transform:rotate(45deg) translate(3px,3px);transform:rotate(45deg) translate(3px,3px)}.open-menu .toggle span:after{-webkit-transform:rotate(-45deg) translate(5px,-6px);transform:rotate(-45deg) translate(5px,-6px)}.caret{display:inline-block;width:0;height:0;margin-left:6px;vertical-align:middle;position:relative;top:-1px;border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}.sidebar{overflow:auto;height:100%;padding-right:15px;padding-bottom:15px;width:285px}.sidebar-wrapper{-webkit-overflow-scrolling:touch;background-color:#2B2F36;left:0;height:100%;overflow-y:hidden;position:fixed;top:0;width:285px;z-index:1}.sidebar-branding{width:160px;padding:0;margin:16px auto}.header{border-bottom:1px solid #E8E8E8;position:relative}.words{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;color:#A0AABF;letter-spacing:1px;text-transform:uppercase;z-index:5;position:absolute;right:16px;top:0}.words span{color:#000}.btn{text-align:center;display:inline-block;width:100%;text-transform:uppercase;font-weight:600;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;text-shadow:0 1px 0 #1b8b77;padding:16px 24px;background-color:#35D7BB;border-radius:3px;margin:0 auto 16px;line-height:1;color:#fff;-webkit-transition:all .15s linear;transition:all .15s linear;-webkit-font-smoothing:antialiased}.btn--new,.btn--save{display:block;width:238px}.btn--new:hover,.btn--new:focus,.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 3px #24b59c;text-shadow:0 1px 0 #24b59c}.btn--save{background-color:#4A5261;text-shadow:0 1px 1px #1e2127}.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 5px #08090a;text-shadow:none}.btn--delete{display:block;width:238px;background-color:transparent;font-size:12px;text-shadow:none}.btn--delete:hover,.btn--delete:focus{color:#fff;border-bottom-color:transparent;text-shadow:0 1px 0 #08090a;opacity:.8}.btn--delete-modal,.btn--ok,.btn--close{border-top:0;background-color:#4A5261;text-shadow:0 1px 0 #08090a;margin:0}.btn--delete-modal:hover,.btn--delete-modal:focus,.btn--ok:hover,.btn--ok:focus,.btn--close:hover,.btn--close:focus{color:#fff;background-color:#292d36;text-shadow:none}.btn--delete-modal{display:inline;width:auto}.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(55,61,73,.8);-webkit-transition:all .25s ease-in-out;transition:all .25s ease-in-out;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;will-change:left,opacity,visibility;z-index:5;opacity:0;visibility:hidden}.show-settings .overlay{visibility:visible;opacity:1}.switch{float:right;line-height:1}.switch input{display:none}.switch small{display:inline-block;cursor:pointer;padding:0 24px 0 0;-webkit-transition:all ease .2s;transition:all ease .2s;background-color:#2B2F36;border-color:#2B2F36}.switch small,.switch small:before{border-radius:30px;box-shadow:inset 0 0 2px 0 #14171F}.switch small:before{display:block;content:'';width:28px;height:28px;background:#fff}.switch.checked small{padding-right:0;padding-left:24px;background-color:#35D7BB;box-shadow:none}.modal--dillinger.about .modal-dialog{font-size:1.25rem;max-width:500px}.modal--dillinger.scope .modal-dialog{max-width:300px;margin:5rem auto}.modal--dillinger .modal-dialog{max-width:600px;width:auto;margin:5rem auto}.modal--dillinger .modal-content{background:#373D49;border-radius:3px;box-shadow:0 2px 5px 0 #2C3B59;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;padding:2rem}.modal--dillinger ul{list-style-type:disc;margin:1rem 0;padding:0 0 0 1rem}.modal--dillinger li{padding:0;margin:0}.modal--dillinger .modal-header{border:0;padding:0}.modal--dillinger .modal-body{padding:0}.modal--dillinger .modal-footer{border:0;padding:0}.modal--dillinger .close{color:#fff;opacity:1}.modal-backdrop{background-color:#373D49}.pagination--dillinger{padding:0!important;margin:1.5rem 0!important;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:stretch;align-content:stretch}.pagination--dillinger,.pagination--dillinger li{display:-webkit-box;display:-ms-flexbox;display:flex}.pagination--dillinger li{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;text-align:center}.pagination--dillinger li:first-child>a,.pagination--dillinger li.disabled>a,.pagination--dillinger li.disabled>a:hover,.pagination--dillinger li.disabled>a:focus,.pagination--dillinger li>a{background-color:transparent;border-color:#4F535B;border-right-color:transparent}.pagination--dillinger li.active>a,.pagination--dillinger li.active>a:hover,.pagination--dillinger li.active>a:focus{border-color:#4A5261;background-color:#4A5261;color:#fff}.pagination--dillinger li>a{float:none;color:#fff;width:100%;display:block;text-align:center;margin:0;border-right-color:transparent;padding:6px}.pagination--dillinger li>a:hover,.pagination--dillinger li>a:focus{border-color:#35D7BB;background-color:#35D7BB;color:#fff}.pagination--dillinger li:last-child a{border-color:#4F535B}.pagination--dillinger li:first-child a{border-right-color:transparent}.diNotify{position:absolute;z-index:9999;left:0;right:0;top:0;margin:0 auto;max-width:400px;text-align:center;-webkit-transition:top .5s ease-in-out,opacity .5s ease-in-out;transition:top .5s ease-in-out,opacity .5s ease-in-out;visibility:hidden}.diNotify-body{-webkit-font-smoothing:antialiased;background-color:#35D7BB;background:#666E7F;border-radius:3px;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;overflow:hidden;padding:1rem 2rem .5rem;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.diNotify-icon{display:block;width:16px;height:16px;line-height:16px;position:relative;top:3px}.diNotify-message{padding-left:1rem}.zen-wrapper{position:fixed;top:0;left:0;right:0;bottom:0;width:100%;height:100%;z-index:10;background-color:#FFF;opacity:0;-webkit-transition:opacity .25s ease-in-out;transition:opacity .25s ease-in-out}.zen-wrapper.on{opacity:1}.enter-zen-mode{background-image:url("../img/icons/enter-zen.svg");right:.5rem;top:.313rem;display:none}.enter-zen-mode,.close-zen-mode{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute}.close-zen-mode{background-image:url("../img/icons/exit-zen.svg");right:1rem;top:1rem}.zen-page{position:relative;top:0;bottom:0;z-index:11;height:100%;width:100%}#zen{font-size:1.25rem;width:300px;height:80%;margin:0 auto;position:relative;top:10%}#zen:before,#zen:after{content:"";position:absolute;height:10%;width:100%;z-index:12;pointer-events:none}#preview .table{width:auto}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;z-index:99999;display:block}.ui-resizable-e{background-color:#666;border-right:8px solid #e8e8e8;border-left:1px solid #222;width:10px;z-index:88!important;position:relative}.ui-resizable-e:after{content:"-";display:block;position:absolute;top:calc(50% - 16px);left:0;height:25px;width:2px;background-color:rgba(0,0,0,.4);margin:3px}#editor{cursor:ew-resize;position:relative;z-index:auto}.profile-pic{float:left;width:250px}.ad-container a::before{color:#A0AABF;content:"Ad:  "}.ad-container{display:block;float:left;max-width:38%;word-wrap:break-word}.ad-container a{display:block;font-size:.75rem;height:51px;letter-spacing:1px;line-height:1rem;padding:18px 24px}.ad-container img{display:none}.split{overflow:scroll;padding:0!important}.split-editor{padding-left:0;padding-right:0;position:relative;z-index:3}.show-preview .split-editor{display:none}.split-preview{background-color:#fff;display:none;top:0;position:relative;z-index:4}.show-preview .split-preview{display:block}#editor{font-size:1rem;font-family:"Ubuntu Mono",Monaco;font-weight:400;line-height:2rem;width:100%;height:100%}#editor .ace_gutter{-webkit-font-smoothing:antialiased}.editor-header{width:50%;float:left;border-bottom:1px solid #E8E8E8;position:relative}.editor-header--first{border-right:1px solid #E8E8E8}.editor-header .title{display:inline-block}#preview{padding:15px}#preview a{color:#A0AABF;text-decoration:underline}.sr-only{visibility:hidden;text-overflow:110%;overflow:hidden;top:-100px;position:absolute}.mnone{margin:0!important}@media screen and (min-width:27.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--m1of1{width:100%}.g-b--m1of2,.g-b--m2of4,.g-b--m3of6,.g-b--m4of8,.g-b--m5of10,.g-b--m6of12{width:50%}.g-b--m1of3,.g-b--m2of6,.g-b--m4of12{width:33.333%}.g-b--m2of3,.g-b--m4of6,.g-b--m8of12{width:66.666%}.g-b--m1of4,.g-b--m2of8,.g-b--m3of12{width:25%}.g-b--m3of4,.g-b--m6of8,.g-b--m9of12{width:75%}.g-b--m1of5,.g-b--m2of10{width:20%}.g-b--m2of5,.g-b--m4of10{width:40%}.g-b--m3of5,.g-b--m6of10{width:60%}.g-b--m4of5,.g-b--m8of10{width:80%}.g-b--m1of6,.g-b--m2of12{width:16.666%}.g-b--m5of6,.g-b--m10of12{width:83.333%}.g-b--m1of8{width:12.5%}.g-b--m3of8{width:37.5%}.g-b--m5of8{width:62.5%}.g-b--m7of8{width:87.5%}.g-b--m1of10{width:10%}.g-b--m3of10{width:30%}.g-b--m7of10{width:70%}.g-b--m9of10{width:90%}.g-b--m1of12{width:8.333%}.g-b--m5of12{width:41.666%}.g-b--m7of12{width:58.333%}.g-b--m11of12{width:91.666%}.g-b--push--m1of1{margin-left:100%}.g-b--push--m1of2,.g-b--push--m2of4,.g-b--push--m3of6,.g-b--push--m4of8,.g-b--push--m5of10,.g-b--push--m6of12{margin-left:50%}.g-b--push--m1of3,.g-b--push--m2of6,.g-b--push--m4of12{margin-left:33.333%}.g-b--push--m2of3,.g-b--push--m4of6,.g-b--push--m8of12{margin-left:66.666%}.g-b--push--m1of4,.g-b--push--m2of8,.g-b--push--m3of12{margin-left:25%}.g-b--push--m3of4,.g-b--push--m6of8,.g-b--push--m9of12{margin-left:75%}.g-b--push--m1of5,.g-b--push--m2of10{margin-left:20%}.g-b--push--m2of5,.g-b--push--m4of10{margin-left:40%}.g-b--push--m3of5,.g-b--push--m6of10{margin-left:60%}.g-b--push--m4of5,.g-b--push--m8of10{margin-left:80%}.g-b--push--m1of6,.g-b--push--m2of12{margin-left:16.666%}.g-b--push--m5of6,.g-b--push--m10of12{margin-left:83.333%}.g-b--push--m1of8{margin-left:12.5%}.g-b--push--m3of8{margin-left:37.5%}.g-b--push--m5of8{margin-left:62.5%}.g-b--push--m7of8{margin-left:87.5%}.g-b--push--m1of10{margin-left:10%}.g-b--push--m3of10{margin-left:30%}.g-b--push--m7of10{margin-left:70%}.g-b--push--m9of10{margin-left:90%}.g-b--push--m1of12{margin-left:8.333%}.g-b--push--m5of12{margin-left:41.666%}.g-b--push--m7of12{margin-left:58.333%}.g-b--push--m11of12{margin-left:91.666%}.g-b--pull--m1of1{margin-right:100%}.g-b--pull--m1of2,.g-b--pull--m2of4,.g-b--pull--m3of6,.g-b--pull--m4of8,.g-b--pull--m5of10,.g-b--pull--m6of12{margin-right:50%}.g-b--pull--m1of3,.g-b--pull--m2of6,.g-b--pull--m4of12{margin-right:33.333%}.g-b--pull--m2of3,.g-b--pull--m4of6,.g-b--pull--m8of12{margin-right:66.666%}.g-b--pull--m1of4,.g-b--pull--m2of8,.g-b--pull--m3of12{margin-right:25%}.g-b--pull--m3of4,.g-b--pull--m6of8,.g-b--pull--m9of12{margin-right:75%}.g-b--pull--m1of5,.g-b--pull--m2of10{margin-right:20%}.g-b--pull--m2of5,.g-b--pull--m4of10{margin-right:40%}.g-b--pull--m3of5,.g-b--pull--m6of10{margin-right:60%}.g-b--pull--m4of5,.g-b--pull--m8of10{margin-right:80%}.g-b--pull--m1of6,.g-b--pull--m2of12{margin-right:16.666%}.g-b--pull--m5of6,.g-b--pull--m10of12{margin-right:83.333%}.g-b--pull--m1of8{margin-right:12.5%}.g-b--pull--m3of8{margin-right:37.5%}.g-b--pull--m5of8{margin-right:62.5%}.g-b--pull--m7of8{margin-right:87.5%}.g-b--pull--m1of10{margin-right:10%}.g-b--pull--m3of10{margin-right:30%}.g-b--pull--m7of10{margin-right:70%}.g-b--pull--m9of10{margin-right:90%}.g-b--pull--m1of12{margin-right:8.333%}.g-b--pull--m5of12{margin-right:41.666%}.g-b--pull--m7of12{margin-right:58.333%}.g-b--pull--m11of12{margin-right:91.666%}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:400px}#editor{font-size:1rem}}@media screen and (min-width:46.25em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--t1of1{width:100%}.g-b--t1of2,.g-b--t2of4,.g-b--t3of6,.g-b--t4of8,.g-b--t5of10,.g-b--t6of12{width:50%}.g-b--t1of3,.g-b--t2of6,.g-b--t4of12{width:33.333%}.g-b--t2of3,.g-b--t4of6,.g-b--t8of12{width:66.666%}.g-b--t1of4,.g-b--t2of8,.g-b--t3of12{width:25%}.g-b--t3of4,.g-b--t6of8,.g-b--t9of12{width:75%}.g-b--t1of5,.g-b--t2of10{width:20%}.g-b--t2of5,.g-b--t4of10{width:40%}.g-b--t3of5,.g-b--t6of10{width:60%}.g-b--t4of5,.g-b--t8of10{width:80%}.g-b--t1of6,.g-b--t2of12{width:16.666%}.g-b--t5of6,.g-b--t10of12{width:83.333%}.g-b--t1of8{width:12.5%}.g-b--t3of8{width:37.5%}.g-b--t5of8{width:62.5%}.g-b--t7of8{width:87.5%}.g-b--t1of10{width:10%}.g-b--t3of10{width:30%}.g-b--t7of10{width:70%}.g-b--t9of10{width:90%}.g-b--t1of12{width:8.333%}.g-b--t5of12{width:41.666%}.g-b--t7of12{width:58.333%}.g-b--t11of12{width:91.666%}.g-b--push--t1of1{margin-left:100%}.g-b--push--t1of2,.g-b--push--t2of4,.g-b--push--t3of6,.g-b--push--t4of8,.g-b--push--t5of10,.g-b--push--t6of12{margin-left:50%}.g-b--push--t1of3,.g-b--push--t2of6,.g-b--push--t4of12{margin-left:33.333%}.g-b--push--t2of3,.g-b--push--t4of6,.g-b--push--t8of12{margin-left:66.666%}.g-b--push--t1of4,.g-b--push--t2of8,.g-b--push--t3of12{margin-left:25%}.g-b--push--t3of4,.g-b--push--t6of8,.g-b--push--t9of12{margin-left:75%}.g-b--push--t1of5,.g-b--push--t2of10{margin-left:20%}.g-b--push--t2of5,.g-b--push--t4of10{margin-left:40%}.g-b--push--t3of5,.g-b--push--t6of10{margin-left:60%}.g-b--push--t4of5,.g-b--push--t8of10{margin-left:80%}.g-b--push--t1of6,.g-b--push--t2of12{margin-left:16.666%}.g-b--push--t5of6,.g-b--push--t10of12{margin-left:83.333%}.g-b--push--t1of8{margin-left:12.5%}.g-b--push--t3of8{margin-left:37.5%}.g-b--push--t5of8{margin-left:62.5%}.g-b--push--t7of8{margin-left:87.5%}.g-b--push--t1of10{margin-left:10%}.g-b--push--t3of10{margin-left:30%}.g-b--push--t7of10{margin-left:70%}.g-b--push--t9of10{margin-left:90%}.g-b--push--t1of12{margin-left:8.333%}.g-b--push--t5of12{margin-left:41.666%}.g-b--push--t7of12{margin-left:58.333%}.g-b--push--t11of12{margin-left:91.666%}.g-b--pull--t1of1{margin-right:100%}.g-b--pull--t1of2,.g-b--pull--t2of4,.g-b--pull--t3of6,.g-b--pull--t4of8,.g-b--pull--t5of10,.g-b--pull--t6of12{margin-right:50%}.g-b--pull--t1of3,.g-b--pull--t2of6,.g-b--pull--t4of12{margin-right:33.333%}.g-b--pull--t2of3,.g-b--pull--t4of6,.g-b--pull--t8of12{margin-right:66.666%}.g-b--pull--t1of4,.g-b--pull--t2of8,.g-b--pull--t3of12{margin-right:25%}.g-b--pull--t3of4,.g-b--pull--t6of8,.g-b--pull--t9of12{margin-right:75%}.g-b--pull--t1of5,.g-b--pull--t2of10{margin-right:20%}.g-b--pull--t2of5,.g-b--pull--t4of10{margin-right:40%}.g-b--pull--t3of5,.g-b--pull--t6of10{margin-right:60%}.g-b--pull--t4of5,.g-b--pull--t8of10{margin-right:80%}.g-b--pull--t1of6,.g-b--pull--t2of12{margin-right:16.666%}.g-b--pull--t5of6,.g-b--pull--t10of12{margin-right:83.333%}.g-b--pull--t1of8{margin-right:12.5%}.g-b--pull--t3of8{margin-right:37.5%}.g-b--pull--t5of8{margin-right:62.5%}.g-b--pull--t7of8{margin-right:87.5%}.g-b--pull--t1of10{margin-right:10%}.g-b--pull--t3of10{margin-right:30%}.g-b--pull--t7of10{margin-right:70%}.g-b--pull--t9of10{margin-right:90%}.g-b--pull--t1of12{margin-right:8.333%}.g-b--pull--t5of12{margin-right:41.666%}.g-b--pull--t7of12{margin-right:58.333%}.g-b--pull--t11of12{margin-right:91.666%}.splashscreen-dillinger{width:500px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--save-to,.menu .menu-item--import-from{display:block}.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar{display:none}.settings a{font-size:1.25rem}.words{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog{font-size:1.25rem}.enter-zen-mode{display:block}.close-zen-mode{right:3rem;top:3rem}#zen{font-size:1.25rem;width:500px}.split-editor{border-right:1px solid #E8E8E8;float:left;height:calc(100vh - 172px);-webkit-overflow-scrolling:touch;padding-right:16px;width:50%}.show-preview .split-editor{display:block}.split-preview{display:block;float:right;height:calc(100vh - 172px);-webkit-overflow-scrolling:touch;position:relative;top:0;width:50%}#editor{font-size:1rem}}@media screen and (min-width:62.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--d1of1{width:100%}.g-b--d1of2,.g-b--d2of4,.g-b--d3of6,.g-b--d4of8,.g-b--d5of10,.g-b--d6of12{width:50%}.g-b--d1of3,.g-b--d2of6,.g-b--d4of12{width:33.333%}.g-b--d2of3,.g-b--d4of6,.g-b--d8of12{width:66.666%}.g-b--d1of4,.g-b--d2of8,.g-b--d3of12{width:25%}.g-b--d3of4,.g-b--d6of8,.g-b--d9of12{width:75%}.g-b--d1of5,.g-b--d2of10{width:20%}.g-b--d2of5,.g-b--d4of10{width:40%}.g-b--d3of5,.g-b--d6of10{width:60%}.g-b--d4of5,.g-b--d8of10{width:80%}.g-b--d1of6,.g-b--d2of12{width:16.666%}.g-b--d5of6,.g-b--d10of12{width:83.333%}.g-b--d1of8{width:12.5%}.g-b--d3of8{width:37.5%}.g-b--d5of8{width:62.5%}.g-b--d7of8{width:87.5%}.g-b--d1of10{width:10%}.g-b--d3of10{width:30%}.g-b--d7of10{width:70%}.g-b--d9of10{width:90%}.g-b--d1of12{width:8.333%}.g-b--d5of12{width:41.666%}.g-b--d7of12{width:58.333%}.g-b--d11of12{width:91.666%}.g-b--push--d1of1{margin-left:100%}.g-b--push--d1of2,.g-b--push--d2of4,.g-b--push--d3of6,.g-b--push--d4of8,.g-b--push--d5of10,.g-b--push--d6of12{margin-left:50%}.g-b--push--d1of3,.g-b--push--d2of6,.g-b--push--d4of12{margin-left:33.333%}.g-b--push--d2of3,.g-b--push--d4of6,.g-b--push--d8of12{margin-left:66.666%}.g-b--push--d1of4,.g-b--push--d2of8,.g-b--push--d3of12{margin-left:25%}.g-b--push--d3of4,.g-b--push--d6of8,.g-b--push--d9of12{margin-left:75%}.g-b--push--d1of5,.g-b--push--d2of10{margin-left:20%}.g-b--push--d2of5,.g-b--push--d4of10{margin-left:40%}.g-b--push--d3of5,.g-b--push--d6of10{margin-left:60%}.g-b--push--d4of5,.g-b--push--d8of10{margin-left:80%}.g-b--push--d1of6,.g-b--push--d2of12{margin-left:16.666%}.g-b--push--d5of6,.g-b--push--d10of12{margin-left:83.333%}.g-b--push--d1of8{margin-left:12.5%}.g-b--push--d3of8{margin-left:37.5%}.g-b--push--d5of8{margin-left:62.5%}.g-b--push--d7of8{margin-left:87.5%}.g-b--push--d1of10{margin-left:10%}.g-b--push--d3of10{margin-left:30%}.g-b--push--d7of10{margin-left:70%}.g-b--push--d9of10{margin-left:90%}.g-b--push--d1of12{margin-left:8.333%}.g-b--push--d5of12{margin-left:41.666%}.g-b--push--d7of12{margin-left:58.333%}.g-b--push--d11of12{margin-left:91.666%}.g-b--pull--d1of1{margin-right:100%}.g-b--pull--d1of2,.g-b--pull--d2of4,.g-b--pull--d3of6,.g-b--pull--d4of8,.g-b--pull--d5of10,.g-b--pull--d6of12{margin-right:50%}.g-b--pull--d1of3,.g-b--pull--d2of6,.g-b--pull--d4of12{margin-right:33.333%}.g-b--pull--d2of3,.g-b--pull--d4of6,.g-b--pull--d8of12{margin-right:66.666%}.g-b--pull--d1of4,.g-b--pull--d2of8,.g-b--pull--d3of12{margin-right:25%}.g-b--pull--d3of4,.g-b--pull--d6of8,.g-b--pull--d9of12{margin-right:75%}.g-b--pull--d1of5,.g-b--pull--d2of10{margin-right:20%}.g-b--pull--d2of5,.g-b--pull--d4of10{margin-right:40%}.g-b--pull--d3of5,.g-b--pull--d6of10{margin-right:60%}.g-b--pull--d4of5,.g-b--pull--d8of10{margin-right:80%}.g-b--pull--d1of6,.g-b--pull--d2of12{margin-right:16.666%}.g-b--pull--d5of6,.g-b--pull--d10of12{margin-right:83.333%}.g-b--pull--d1of8{margin-right:12.5%}.g-b--pull--d3of8{margin-right:37.5%}.g-b--pull--d5of8{margin-right:62.5%}.g-b--pull--d7of8{margin-right:87.5%}.g-b--pull--d1of10{margin-right:10%}.g-b--pull--d3of10{margin-right:30%}.g-b--pull--d7of10{margin-right:70%}.g-b--pull--d9of10{margin-right:90%}.g-b--pull--d1of12{margin-right:8.333%}.g-b--pull--d5of12{margin-right:41.666%}.g-b--pull--d7of12{margin-right:58.333%}.g-b--pull--d11of12{margin-right:91.666%}.splashscreen-dillinger{width:700px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--export-as{display:block}.menu .menu-item--preview{display:none}.settings a{font-size:1.25rem}.words{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:700px}#editor{font-size:1rem}}@media screen and (min-width:87.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.splashscreen-dillinger{width:800px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#editor{font-size:1rem}}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn,.form-inline .input-group .form-control{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .radio label,.form-inline .checkbox label{padding-left:0}.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}.form-horizontal .control-label{text-align:right;margin-bottom:0;padding-top:7px}.form-horizontal .form-group-lg .control-label{padding-top:14.3px}.form-horizontal .form-group-sm .control-label{padding-top:6px}.modal-dialog{width:600px;margin:30px auto}.modal-content{box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}@media screen and (max-width:1200px){.ad-container{max-width:30%}.ad-container a{font-size:.825rem;line-height:.875rem;padding:12px 12px 6px 24px;text-align:justify}}@media screen and (max-width:1100px){.ad-container{max-width:27%}.ad-container a{font-size:.8rem;line-height:.85rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:1000px){.ad-container{max-width:24%}.ad-container a{font-size:.775rem;line-height:.8rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:900px){.ad-container{max-width:30%}}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;overflow-x:auto;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd;-webkit-overflow-scrolling:touch}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>thead>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>tfoot>tr>td{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0}}@media screen and (max-width:720px){.ad-container{max-width:50%}.ad-container a{font-size:.75rem;line-height:1rem;padding:12px 24px}}@media screen and (max-width:620px){.ad-container{max-width:40%}.ad-container a{font-size:.66rem;letter-spacing:1px;line-height:1rem;padding:6px 24px}}@media screen and (max-width:520px){.ad-container a{font-size:.4rem;line-height:.875rem;padding:6px 12px 6px 24px;text-align:justify}}@media screen and (max-width:460px){.ad-container{display:none}}@media screen and (max-width:46.1875em){.editor-header{display:none}.editor-header--first{display:block;width:100%}}</style></head><body id="preview">
<h1><a id="Reactive_Python_for_Data_0"></a>Reactive Python for Data</h1>
<h1><a id="Part_IV__The_Observable_1"></a>Part IV - The Observable</h1>
<h2><a id="41A__Creating_an_Observable_3"></a>4.1A - Creating an <code>Observable</code></h2>
<p>An <code>Observable</code> pushes items. It can push a finite or infinite series of items over time. To create an <code>Observable</code> that pushes 5 text strings, you can declare it like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

letters = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])
</code></pre>
<p>We create an <code>Observable</code> using the <code>from_()</code> function, and pass it a list of five strings. It will take the list and <strong>emit</strong> (or push) each item from it. The <code>Observable.from_()</code> will work with any iterable.</p>
<p>However, running this does nothing more than save an <code>Observable</code> to a variable called <code>letters</code>. For the items to actually get pushed, we need a <code>Subscriber</code>.</p>
<h2><a id="41B__Subscribing_to_an_Observable_17"></a>4.1B - Subscribing to an <code>Observable</code></h2>
<p>To receive emissions from an <code>Observable</code>, we need to create a <code>Subscriber</code> by implementing an <code>Observer</code>. An <code>Observer</code> implements three functions <code>on_next()</code> which receives an emission, <code>on_completed()</code> which is called when there are no more items, and <code>on_error()</code> which receives an error in the event one occurs.</p>
<p>Then we can pass an implementation of this <code>Observer</code> to the Observable’s <code>subscribe()</code> function. It will then fire the emissions to our <code>Subscriber</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable, Observer

letters = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySubscriber</span><span class="hljs-params">(Observer)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_next</span><span class="hljs-params">(self, value)</span>:</span>
        print(value)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_completed</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"Completed!"</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_error</span><span class="hljs-params">(self, error)</span>:</span>
        print(<span class="hljs-string">"Error occured: {0}"</span>.format(error))


letters.subscribe(MySubscriber())
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Received: Alpha
Received: Beta
Received: Gamma
Received: Delta
Received: Epsilon
Completed!
</code></pre>
<h2><a id="Example_31C__Subscribing_Shorthand_with_Lambdas_54"></a>Example 3.1C - Subscribing Shorthand with Lambdas</h2>
<p>Implementing a <code>Subscriber</code> is a bit verbose, so we also have the option of passing more concise lambda arguemnts to the <code>subscribe()</code> function. Then it will use those lambas to create the <code>Subscriber</code> for us.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-number">31</span>
letters = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])

letters.subscribe(on_next = <span class="hljs-keyword">lambda</span> value: print(value),
                  on_completed = <span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"Completed!"</span>),
                  on_error = <span class="hljs-keyword">lambda</span> error: print(<span class="hljs-string">"Error occurred: {0}"</span>.format(error)))
</code></pre>
<p>You do not even have to supply all the lambda arguments. You can leave out the <code>on_completed</code> and <code>on_error</code>, but for production code you should try to have an <code>on_error</code> so errors are not quietly swallowed.</p>
<pre><code class="language-python">letters.subscribe(on_next = <span class="hljs-keyword">lambda</span> value: print(value))

<span class="hljs-comment"># or</span>

letters.subscribe(<span class="hljs-keyword">lambda</span> value: print(<span class="hljs-string">"Received: {0}"</span>.format(value)))
</code></pre>
<p>We will be using lambdas constantly as we do reactive programming.</p>
<h2><a id="42A__Some_Basic_Operators_82"></a>4.2A - Some Basic Operators</h2>
<p>RxPy has approximately 130 operators to powerfully express business 
logic, transformations, and concurrency behaviors. For now we will start
 with two basic ones: <code>map()</code> and <code>filter()</code> and cover more in the next section.</p>
<p>For instance, we can <code>map()</code> each <code>String</code> to its lenth, and then filter only to lengths that are at least 5.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

letters = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])

mapped = letters.map(<span class="hljs-keyword">lambda</span> s: len(s))

filtered = mapped.filter(<span class="hljs-keyword">lambda</span> i: i &gt;= <span class="hljs-number">5</span>)

filtered.subscribe(<span class="hljs-keyword">lambda</span> value: print(value))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Received: 5
Received: 5
Received: 5
Received: 7
</code></pre>
<p>Each operator yields a new <code>Observable</code> emitting that transformation. We can save each one to a variable if we want and then <code>subscribe()</code> to the one we want, but oftentimes you will likely want to call them all in a single chain.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .filter(<span class="hljs-keyword">lambda</span> i: i &gt;= <span class="hljs-number">5</span>) \
    .subscribe(<span class="hljs-keyword">lambda</span> value: print(value))
</code></pre>
<blockquote>
<p>If you are using an IDE like PyCharm, operators like <code>filter()</code> and <code>map()</code> will unfortunately not be available for auto-complete. The reason is RxPy will add these operators to the <code>Observable</code> at runtime. For PyCharm, you may want to disable <em>Unresolved References</em> under <em>Settings -&gt; Editor -&gt; Inspection -&gt; Python</em> so you do not get any warnings.</p>
</blockquote>
<h2><a id="42B_Using_Observablerange_122"></a>4.2B Using Observable.range()</h2>
<p>There are other ways to create an <code>Observable</code>. For instance, you can emit a range of numbers:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

letters = Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)

letters.subscribe(<span class="hljs-keyword">lambda</span> value: print(value))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Received: 1
Received: 2
Received: 3
Received: 4
Received: 5
Received: 6
Received: 7
Received: 8
Received: 9
Received: 10
</code></pre>
<p>You can also use <code>Observable.just()</code> to emit a single item.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable, Observer

greeting = Observable.just(<span class="hljs-string">"Hello World!"</span>)

greeting.subscribe(<span class="hljs-keyword">lambda</span> value: print(value))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Received: Hello World!
</code></pre>
<h1><a id="32C__Using_Observableempty_165"></a>3.2C - Using Observable.empty()</h1>
<p>You can also create an <code>Observable</code> that emits nothing and call <code>on_completed()</code> immediately via <code>Observable.empty()</code>. While this may not seem useful, an empty <code>Observable</code> is the reactive equivalent to <code>None</code>, <code>null</code>, or an empty collection so you will encounter it.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.empty() \
    .subscribe(on_next= <span class="hljs-keyword">lambda</span> s: print(s),
               on_completed= <span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"Done!"</span>)
               )
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Done!
</code></pre>
<h1><a id="33A__Creating_an_Observable_from_Scratch_184"></a>3.3A - Creating an Observable from Scratch</h1>
<p>You can also create an <code>Observable</code> source from scratch. Using <code>Observable.create()</code>. you can pass a function with an <code>observer</code> argument, and call it’s <code>on_next()</code>, <code>on_completed()</code>, and <code>on_error()</code> to pass items or events to the <code>Subscriber</code> or the next operator in the chain.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable, Observer

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_numbers</span><span class="hljs-params">(observer)</span>:</span>
    observer.on_next(<span class="hljs-number">100</span>)
    observer.on_next(<span class="hljs-number">300</span>)
    observer.on_next(<span class="hljs-number">500</span>)
    observer.on_completed()

Observable.create(push_numbers).subscribe(on_next = <span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>100
300
500
</code></pre>
<h2><a id="43B__An_Interval_Observable_209"></a>4.3B - An Interval Observable</h2>
<p>Observables do not have to strictly emit data. They can also emit events. Remember our definition that <em>events are data, and data are events</em>? Events and data are treated the same way in ReactiveX. They both can be pushed through an <code>Observable</code>.</p>
<p>For instance, we can use <code>Observable.interval()</code> to emit a consecutive integer every 1 second.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.interval(<span class="hljs-number">1000</span>) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"{0} Mississippi"</span>.format(i)) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

<span class="hljs-comment"># Keep application alive until user presses a key</span>
input(<span class="hljs-string">"Press any key to quit"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>0 Mississippi
1 Mississippi
2 Mississippi
3 Mississippi
4 Mississippi
5 Mississippi
6 Mississippi
7 Mississippi
8 Mississippi
</code></pre>
<p>Notice how the <code>Observable</code> in fact has a notion of time? 
It is emitting an integer every second, and each emission is both data 
and an event. Observables can be created to emit button clicks for a UI,
 server requests, new Tweets, and any other event while repsresenting 
that event as data.</p>
<p>Note also we had to use <code>input()</code> to make the main thread pause until the user presses a key. If we did not do this, the <code>Observable.interval()</code> would not have a chance to fire because the application will exit. The reason for this is the <code>Observable.interval()</code>
 has to operate on a separate thread and create a separate workstream 
driven by a timer. The Python code will finish and terminate before it 
has a chance to fire.</p>
<h1><a id="33C__Unsubscribing_from_an_Observable_245"></a>3.3C - Unsubscribing from an Observable</h1>
<p>When you <code>subscribe()</code> to an <code>Observable</code> it returns a <code>Disposable</code> so you can disconnect the <code>Subscriber</code> from the <code>Observable</code> at any time.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> time

disposable = Observable.interval(<span class="hljs-number">1000</span>) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"{0} Mississippi"</span>.format(i)) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

<span class="hljs-comment"># sleep 5 seconds so Observable can fire</span>
time.sleep(<span class="hljs-number">5</span>)

<span class="hljs-comment"># disconnect the Subscriber</span>
print(<span class="hljs-string">"Unsubscribing!"</span>)
disposable.dispose()

<span class="hljs-comment"># sleep a bit longer to prove no more emissions are coming</span>
time.sleep(<span class="hljs-number">5</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>0 Mississippi
1 Mississippi
2 Mississippi
3 Mississippi
Unsubscribing!
</code></pre>
<p>Unsubscribing/disposing is usually not necessary for Observables that
 are finite and quick (they will unsubscribe themselves), but it can be 
necessary for long-running or infinite Observables.</p>
<h1><a id="34__An_Observable_emitting_Tweets_280"></a>3.4 - An Observable emitting Tweets</h1>
<p>Later we will learn how to create Observables that emit Tweets for a 
given topic, but here is a preview of what’s to come. Using Tweepy and <code>Observable.create()</code>, we can create a function that yields an <code>Observable</code>
 emitting Tweets for specified topics. For instance, here is how to get a
 live stream of text bodies from Tweets for “Britain” and “France”.</p>
<h2><a id="44A__A_Twitter_Observable_285"></a>4.4A - A Twitter Observable</h2>
<pre><code class="language-python"><span class="hljs-keyword">from</span> tweepy.streaming <span class="hljs-keyword">import</span> StreamListener
<span class="hljs-keyword">from</span> tweepy <span class="hljs-keyword">import</span> OAuthHandler
<span class="hljs-keyword">from</span> tweepy <span class="hljs-keyword">import</span> Stream
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

<span class="hljs-comment"># Variables that contains the user credentials to access Twitter API</span>
access_token = <span class="hljs-string">"CONFIDENTIAL"</span>
access_token_secret = <span class="hljs-string">"CONFIDENTIAL"</span>
consumer_key = <span class="hljs-string">"CONFIDENTIAL"</span>
consumer_secret = <span class="hljs-string">"CONFIDENTIAL"</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tweets_for</span><span class="hljs-params">(topics)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">observe_tweets</span><span class="hljs-params">(observer)</span>:</span>
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TweetListener</span><span class="hljs-params">(StreamListener)</span>:</span>
            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_data</span><span class="hljs-params">(self, data)</span>:</span>
                observer.on_next(data)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_error</span><span class="hljs-params">(self, status)</span>:</span>
                observer.on_error(status)

        <span class="hljs-comment"># This handles Twitter authetification and the connection to Twitter Streaming API</span>
        l = TweetListener()
        auth = OAuthHandler(consumer_key, consumer_secret)
        auth.set_access_token(access_token, access_token_secret)
        stream = Stream(auth, l)
        stream.filter(track=topics)

    <span class="hljs-keyword">return</span> Observable.create(observe_tweets).share()


topics = [<span class="hljs-string">'Britain'</span>,<span class="hljs-string">'France'</span>]

tweets_for(topics).map(<span class="hljs-keyword">lambda</span> d: json.loads(d)) \
    .filter(<span class="hljs-keyword">lambda</span> map: <span class="hljs-string">"text"</span> <span class="hljs-keyword">in</span> map) \
    .map(<span class="hljs-keyword">lambda</span> map: map[<span class="hljs-string">"text"</span>].strip()) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))


</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>RT @YourAnonCentral: The ﬁve biggest international arms exports suppliers in 2008–12 were the #US,#Russia, #Germany, #France and #China. ht…
RT @parismarx: Marine Le Pen believes France "will provide the third stage of a global political uprising" following Brexit &amp;amp; Trump https:/…
Attentats du 13-Novembre: des rescapés racontent leur vie un an après https://t.co/VMM5rlsoQu via @RFI
RT @AOLNews: 1 year after the Paris attacks, France's state of emergency remains: https://t.co/PD0U6mXHcN https://t.co/QUHWRSCLxt
おむつは不要、手ぶらで登園。少子化を克服したフランスの保育園事情とは https://t.co/4ImUajYSq2 @HuffPostJapanさんから
RT @CPIF_: #France Interdit cette année, les islamistes tentent de convertir les femmes en faisant l'expérience du voile à…
RT @StewartWood: This week our Government should remember &amp;amp; make clear that Britain's alliances must be based on our values, not our values…
RT @MaxAbrahms: "Britain will spend the next two months trying to convince Mr Trump's team of the need to remove President Assad." https://…
RT @Bassounov: #Trump est devenu présidentiable grâce à 10 ans de #téléPoubelle. En 2022 en France, la présidence se jouera entre #Hanouna…
# Panoramix #Radio #Station
...
</code></pre>
<h2><a id="44B_Cold_vs_Hot_Observables_348"></a>4.4B Cold vs Hot Observables</h2>
<p>Observables that emit data typically are <strong>cold Observables</strong>, meaning they will replay emissions to each individual <code>Subscriber</code>. For instance, this <code>Observable</code> below will emit all five strings to both Subscribers individually.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Subscriber 1: Alpha
Subscriber 1: Beta
Subscriber 1: Gamma
Subscriber 1: Delta
Subscriber 1: Epsilon
Subscriber 2: Alpha
Subscriber 2: Beta
Subscriber 2: Gamma
Subscriber 2: Delta
Subscriber 2: Epsilon
</code></pre>
<p>However, <strong>hot Observables</strong> will not replay emissions for tardy subscribers that come later. Our Twitter <code>Observable</code> is an example of a hot <code>Observable</code>. If a second <code>Subscriber</code> subscribes to a Tweet feed 5 seconds after the first <code>Subscriber</code>, it will miss all Tweets that occurred in that window. We will explore this later.</p>
<h1><a id="Part_V__Operators_377"></a>Part V - Operators</h1>
<p>In this section, we will learn some of the 130 operators available in
 RxPy. Learning these operators can be overwhelming, so the best 
approach is to seek the right operators out of need. The key to being 
productive with RxPy and unleashing its potential is to find the key 
operators that help you with the tasks you encounter. With practice, you
 will become fluent in composing them together.</p>
<p>The best way to see what operators are available in RxPy is to look through them on GitHub<br>
<a href="https://github.com/ReactiveX/RxPY/tree/master/rx/linq/observable">https://github.com/ReactiveX/RxPY/tree/master/rx/linq/observable</a></p>
<p>You can also view the ReactiveX operators page which has helpful marble diagrams showing each operator’s behavior<br>
<a href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a></p>
<p>You can also explore various operators using the interactive RxMarbles website<br>
<a href="http://rxmarbles.com/">http://rxmarbles.com/</a></p>
<h2><a id="51_Suppressing_Emissions_391"></a>5.1 Suppressing Emissions</h2>
<p>Here are some operators that can be helpful for supressing emissions that fail to meet a criteria in some form.</p>
<h3><a id="51A_filter_395"></a>5.1A <code>filter()</code></h3>
<p>You have already seen the <code>filter()</code>. It supresses 
emissions that fail to meet a condition specified by you. For instance, 
only allowing emissions forward that are at least length 5.</p>
<pre><code class="language-python">Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .filter(<span class="hljs-keyword">lambda</span> s: len(s) &gt;= <span class="hljs-number">5</span>) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Gamma
Delta
Epsilon
</code></pre>
<h2><a id="51B_take_416"></a>5.1B <code>take()</code></h2>
<p>You can also use <code>take()</code> to cut off at a certain number of emissions and call <code>on_completed()</code>. For instance, calling <code>take(2)</code> like below will only allow the first two emissions coming out of the <code>filter()</code> to come through.</p>
<pre><code class="language-python">Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .filter(<span class="hljs-keyword">lambda</span> s: len(s) &gt;= <span class="hljs-number">5</span>) \
    .take(<span class="hljs-number">2</span>) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Gamma
</code></pre>
<p><code>take()</code> will not throw an error if it fails to get the 
number of items it wants. It will just emit what it does capture. For 
instance, when <code>take(10)</code> only recieves 4 emissions (and not 10), it will just emit those 4 emissions.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .filter(<span class="hljs-keyword">lambda</span> s: len(s) &gt;= <span class="hljs-number">5</span>) \
    .take(<span class="hljs-number">10</span>) \
    .subscribe(on_next = <span class="hljs-keyword">lambda</span> s: print(s), on_error = <span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Beta
Gamma
Delta
Epsilon
</code></pre>
<h2><a id="51C_take_while_455"></a>5.1C <code>take_while()</code></h2>
<p><code>take_while()</code> and <code>take_until()</code> will keep passing emissions based on a condition. For instance if we have an <code>Observable</code> emitting some integers, we can keep taking integers while they are less than 100. We can achieve this using a <code>take_while()</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">21</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">63</span>,<span class="hljs-number">127</span>,<span class="hljs-number">12</span>]) \
    .take_while(<span class="hljs-keyword">lambda</span> i: i &lt; <span class="hljs-number">100</span>) \
    .subscribe(on_next = <span class="hljs-keyword">lambda</span> i: print(i), on_completed = <span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"Done!"</span>))
</code></pre>
<p>When the <code>127</code> is encountered, the <code>take_while()</code> specified as above with the condition <code>i &lt; 100</code> will trigger <code>on_completed()</code> to be called to the <code>Subscriber</code>, and unsubscription will prevent any more emissions from occurring.</p>
<h1><a id="42_Distinct_Operators_471"></a>4.2 Distinct Operators</h1>
<h2><a id="52A_distinct_473"></a>5.2A <code>distinct()</code></h2>
<p>You can use <code>distinct()</code> to suppress redundant emissions. If an item has been emitted before (based on its equality logic via its <code>__eq__</code> implementation), it will not be emitted.</p>
<p>This will emit the distinct lengths</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .distinct() \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>5
4
7
</code></pre>
<h2><a id="52B_distinct_with_mapping_497"></a>5.2B <code>distinct()</code> with mapping</h2>
<p>You can also pass a lambda specifying what you want to distinct on. If we want to emit the <code>String</code> rather than its length, but use distinct logic on its length, you can leverage a lambda argument.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .distinct(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Beta
Epsilon
</code></pre>
<h2><a id="52C_distinct_until_changed_518"></a>5.2C <code>distinct_until_changed()</code></h2>
<p>The <code>distinct_until_changed()</code> will prevent <em>consecutive</em> duplicates from emitting.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Theta"</span>, <span class="hljs-string">"Kappa"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .distinct_until_changed() \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>5
4
5
7
</code></pre>
<p>Just like <code>distinct()</code>, you can also provide a lambda to distinct on an attribute.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Theta"</span>, <span class="hljs-string">"Kappa"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .distinct_until_changed(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<pre><code>Alpha
Beta
Gamma
Epsilon
</code></pre>
<h1><a id="43_Aggregating_Operators_557"></a>4.3 Aggregating Operators</h1>
<p>When working with data, there will be many instances where we want to
 consolidate emissions into a single emission to reflect some form of an
 aggregated result.</p>
<p>With the exception of <code>scan()</code>, one thing to be careful about when aggregating emissions is they rely on <code>on_completed()</code>
 to be called. Infinite Observables will cause an aggregation operator 
to work forever aggregating an infinite series of emissions.</p>
<h2><a id="53A__count_563"></a>5.3A - <code>count()</code></h2>
<p>The simplest aggregation to an <code>Observable</code> is to simply <code>count()</code> the number of emisssions, and then push that count forward as a single emission once <code>on_completed()</code> is called. If we want to count the number of text strings that are not 5 characters, we can achieve it like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .filter(<span class="hljs-keyword">lambda</span> s: len(s) != <span class="hljs-number">5</span>) \
    .count() \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>2
</code></pre>
<h2><a id="53B_reduce_583"></a>5.3B <code>reduce()</code></h2>
<p>The <code>reduce()</code> allows you to define a custom aggregation 
operation to “fold” each value into a rolling value. For instance, you 
can find the sum of numeric emissions (less than 100) using <code>reduce()</code> in this manner.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">4</span>,<span class="hljs-number">76</span>,<span class="hljs-number">22</span>,<span class="hljs-number">66</span>,<span class="hljs-number">881</span>,<span class="hljs-number">13</span>,<span class="hljs-number">35</span>]) \
    .filter(<span class="hljs-keyword">lambda</span> i: i &lt; <span class="hljs-number">100</span>) \
    .reduce(<span class="hljs-keyword">lambda</span> total, value: total + value) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>216
</code></pre>
<p>You can use this to consolidate emissions in your own custom way for 
most cases. Keep in mind that there are already built in mathematical 
aggregators like <code>sum()</code> (which could replace this <code>reduce()</code>) as well as <code>min()</code>, <code>max()</code>, and <code>average()</code>. These only work on numeric emissions, however.</p>
<h2><a id="53C_scan_605"></a>5.3C <code>scan()</code></h2>
<p>The <code>scan()</code> is almost identical to <code>reduce()</code>,
 but it will emit each rolling total for each emission that is received.
 Therefore, it can work with infinite Observables such as Twitter 
streams and other events.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">4</span>,<span class="hljs-number">76</span>,<span class="hljs-number">22</span>,<span class="hljs-number">66</span>,<span class="hljs-number">881</span>,<span class="hljs-number">13</span>,<span class="hljs-number">35</span>]) \
    .scan(<span class="hljs-keyword">lambda</span> total, value: total + value) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>4
80
102
168
1049
1062
1097
</code></pre>
<p>Each accumulation is emitted every time an emission is added to our running total. We start with <code>4</code>, then <code>4</code> + <code>76</code> which is <code>80</code>, then <code>80</code> + <code>22</code> which is <code>102</code>, etc…</p>
<h1><a id="44_Collecting_Operators_633"></a>4.4 Collecting Operators</h1>
<p>You can consolidate emissions by collecting them into a <code>List</code> or <code>Dict</code>, and then pushing that collection forward as a single emission.</p>
<h2><a id="54A__to_list_637"></a>5.4A - <code>to_list()</code></h2>
<p><code>to_list()</code> will collect the emissions into a single <code>List</code> until <code>on_completed()</code> is called, then it will push that <code>List</code> forward as a single emission.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .to_list() \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon']
</code></pre>
<p>Typically you want avoid excessively collecting things into Lists 
unless business logic requires it. Prefer to keep emissions flowing 
forward one-at-a-time in a reactive manner when possible, rather than 
stopping the flow and collecting emissions into Lists.</p>
<h2><a id="54B__to_dict_657"></a>5.4B - <code>to_dict()</code></h2>
<p>The <code>to_dict()</code> will collect emissions into a <code>Dict</code>
 and you specify a lambda that derives the key. For instance, if you 
wanted to key each String off its first letter and collect them into a <code>Dict</code>, do the following:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .to_dict(<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">0</span>]) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{'B': 'Beta', 'E': 'Epsilon', 'A': 'Alpha', 'G': 'Gamma', 'D': 'Delta'}
</code></pre>
<p>You can optionally provide a second lambda argument to specify a 
value other than the emission itself. If we wanted to map the first 
letter to the length of the String instead, we can do this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .to_dict(<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">0</span>], <span class="hljs-keyword">lambda</span> s: len(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{'A': 5, 'B': 4, 'D': 5, 'G': 5, 'E': 7}
``
# Section VI - Combining Observables

We can combine multiple Observables into a single `Observable`, and bring their emissions together in various ways.

# 6.1 Merge

We can merge two or more Observables using the `Observable.merge()` function, and this will yield a new `Observable` pushing emissions from all of them.

## 6.1A - Observable.merge()

```python
from rx import Observable

source1 = Observable.from_(["Alpha","Beta","Gamma","Delta","Epsilon"])
source2 = Observable.from_(["Zeta","Eta","Theta","Iota"])

Observable.merge(source1,source2) \
    .subscribe(lambda s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code class="language-python">Alpha
Zeta
Beta
Eta
Gamma
Theta
Delta
Iota
Epsilon
</code></pre>
<p>Notice that although emissions from both Observable are now a single 
stream, the emissions are interleaved and jumbled. This is because <code>Observable.merge()</code> will fire emissions from all the Observables at once rather than sequentially one-at-a-time.</p>
<h2><a id="61B__Observablemerge_Continued_726"></a>6.1B - Observable.merge() (Continued)</h2>
<p>If you want this sequential ordered guarantee, you will want to use <code>Observable.concat()</code> which is discussed later. But the <code>Observable.merge()</code> can be helpful for merging multiple event streams.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source1 = Observable.interval(<span class="hljs-number">1000</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 1: {0}"</span>.format(i))
source2 = Observable.interval(<span class="hljs-number">500</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 2: {0}"</span>.format(i))
source3 = Observable.interval(<span class="hljs-number">300</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 3: {0}"</span>.format(i))

Observable.merge(source1, source2, source3) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

<span class="hljs-comment"># keep application alive until user presses a key</span>
input(<span class="hljs-string">"Press any key to quit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Source 3: 0
Source 2: 0
Source 3: 1
Source 3: 2
Source 1: 0
Source 2: 1
Source 3: 3
Source 2: 2
Source 3: 4
Source 3: 5
Source 2: 3
Source 1: 1
etc...
</code></pre>
<p>Three infinite Observables above are emitting a consecutive integer 
at different intervals (1000 milliseconds, 500 milliseconds, and 300 
milliseconds), and putting each integer into a String labeling the 
source. But we merged these three infinite Observables into one using <code>Observable.merge()</code>.</p>
<h2><a id="61C__merge_all_764"></a>6.1C - <code>merge_all()</code></h2>
<p>Another way to accomplish this is to make a List containing all three Observables, and then passing it to <code>Observable.from_()</code>. This will make an Observable emitting Observables, then you can call <code>merge_all()</code> to turn each one into its emissions.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source1 = Observable.interval(<span class="hljs-number">1000</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 1: {0}"</span>.format(i))
source2 = Observable.interval(<span class="hljs-number">500</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 2: {0}"</span>.format(i))
source3 = Observable.interval(<span class="hljs-number">300</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"Source 3: {0}"</span>.format(i))

Observable.from_([source1,source2,source3]) \
    .merge_all() \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

<span class="hljs-comment"># keep application alive until user presses a key</span>
input(<span class="hljs-string">"Press any key to quit\n"</span>)
</code></pre>
<h2><a id="61D__merge_all_Continued_783"></a>6.1D - <code>merge_all()</code> (Continued)</h2>
<p>If you are creating an <code>Observable</code> off each emission on-the-fly, <code>merge_all()</code> can be helpful here as well. Say you have a list of Strings containing numbers separated by <code>/</code>. You can map each String to be <code>split()</code> and then pass those separated values to an <code>Observable.from_()</code>. Then you can call <code>merge_all()</code> afterwards.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"134/34/235/132/77"</span>, <span class="hljs-string">"64/22/98/112/86/11"</span>, <span class="hljs-string">"66/08/34/778/22/12"</span>]

Observable.from_(items) \
    .map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split(<span class="hljs-string">"/"</span>))) \
    .merge_all() \
    .map(<span class="hljs-keyword">lambda</span> s: int(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))

</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>134
34
64
235
22
66
132
98
8
77
112
34
86
778
11
22
12
</code></pre>
<h2><a id="61E__flat_map_822"></a>6.1E - <code>flat_map()</code></h2>
<p>An alternative way of expressing the previous example (5.1D) is using <code>flat_map()</code>. It will consolidate mapping to an <code>Observable</code> and calling <code>merge_all()</code> into a single operator.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"134/34/235/132/77"</span>, <span class="hljs-string">"64/22/98/112/86/11"</span>, <span class="hljs-string">"66/08/34/778/22/12"</span>]

Observable.from_(items) \
    .flat_map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split(<span class="hljs-string">"/"</span>))) \
    .map(<span class="hljs-keyword">lambda</span> s: int(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p>We will try to prefer the <code>flat_map()</code> over the <code>map()</code>/<code>merge_all()</code> from now on since it is much more succinct.</p>
<h1><a id="62_Concat_and_Zip_839"></a>6.2 Concat and Zip</h1>
<p><code>Observable.concat()</code> and the <code>concat_all()</code> operator are simliar to <code>Observable.merge()</code> and the <code>merge_all()</code> operator. The only difference is they will emit items from each <code>Observable</code> <em>sequentially</em>. It will fire off each <code>Observable</code>
 in order and one-at-a-time. Therefore, this not something you want to 
use with infinite Observables, because the first infinite <code>Observable</code> will occupy its place in the queue forever and stop the <code>Observables</code> behind it from firing. They are helpful for finite data sets though.</p>
<h2><a id="62A__concat_844"></a>6.2A - <code>concat()</code></h2>
<p>Our previous <code>merge()</code> example can now emit items in order:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source1 = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])
source2 = Observable.from_([<span class="hljs-string">"Zeta"</span>,<span class="hljs-string">"Eta"</span>,<span class="hljs-string">"Theta"</span>,<span class="hljs-string">"Iota"</span>])

Observable.concat(source1,source2) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Beta
Gamma
Delta
Epsilon
Zeta
Eta
Theta
Iota
</code></pre>
<h2><a id="62B__concat_all_872"></a>6.2B - <code>concat_all()</code></h2>
<p>We can make our earlier example splitting Strings ordered using <code>concat_all()</code> instead of <code>merge_all()</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"134/34/235/132/77"</span>, <span class="hljs-string">"64/22/98/112/86/11"</span>, <span class="hljs-string">"66/08/34/778/22/12"</span>]

Observable.from_(items) \
    .map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split(<span class="hljs-string">"/"</span>))) \
    .concat_all() \
    .map(<span class="hljs-keyword">lambda</span> s: int(s)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>134
34
235
132
77
64
22
98
112
86
11
66
08
34
778
22
12
</code></pre>
<p>If you do not care about ordering, it is recommend to use <code>merge_all()</code> or <code>flat_map()</code>. <code>concat_all()</code> can behave unpredictably with certain operators like <code>group_by()</code>, which we will cover later.</p>
<h2><a id="62C__Zip_912"></a>6.2C - Zip</h2>
<p>Zipping pairs emissions from two or more sources and turns them into a single <code>Observable</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

letters = Observable.from_([<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"F"</span>])
numbers = Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)

Observable.zip(letters,numbers, <span class="hljs-keyword">lambda</span> l,n: <span class="hljs-string">"{0}-{1}"</span>.format(l,n)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>A-1
B-2
C-3
D-4
E-5
</code></pre>
<p>You can alternatively express this as an operator.</p>
<pre><code class="language-python">letters.zip(numbers, <span class="hljs-keyword">lambda</span> l,n: <span class="hljs-string">"{0}-{1}"</span>.format(l,n)) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<h2><a id="63D__Using_Zip_to_Space_Emissions_943"></a>6.3D - Using Zip to Space Emissions</h2>
<p>Zip can also be helpful to space out emissions by zipping an Observable with an <code>Observable.interva()</code>. For instnance, we can space out five emissions by one second intervals.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

letters = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])
intervals = Observable.interval(<span class="hljs-number">1000</span>)

Observable.zip(letters,intervals, <span class="hljs-keyword">lambda</span> s,i: s) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

input(<span class="hljs-string">"Press any key to quit\n"</span>)
</code></pre>
<p>Note that <code>zip()</code> can get overwhelmed with infinite hot 
Observables where one produces emissions faster than another. You might 
want to consider using <code>combine_latest()</code> or <code>with_latest_from()</code> instead of <code>zip()</code>,
 which will pair with the latest emission from each source. For the sake
 of brevity, we will not cover this in this course. But you can read 
more about it in the ReactiveX documentation.</p>
<h1><a id="64_group_by_962"></a>6.4 group_by</h1>
<p>For the purposes of data science, one of the most powerful operators in ReactiveX is <code>group_by()</code>. It will yield an Observable emitting GroupedObservables, where each <code>GroupedObservable</code> pushes items with a given key. It behaves just like any other <code>Observable</code>, but it has a <code>key</code> property which we will leverage in a moment.</p>
<p>But first, let’s group some <code>String</code> emissions by keying on their lengths. Then let’s collect emissions for each grouping into a <code>List</code>. Then we can call <code>flat_map()</code> to yield all the Lists.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]

Observable.from_(items) \
    .group_by(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .flat_map(<span class="hljs-keyword">lambda</span> grp: grp.to_list()) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>['Alpha', 'Gamma', 'Delta']
['Beta']
['Epsilon']
</code></pre>
<p><code>group_by()</code> is efficient because it is still 100% 
reactive and pushing items one-at-a-time through the different 
GroupedObservables. You can also leverage the <code>key</code> property and tuple it up with an aggregated value. This is helpful if you want to create <code>Dict</code> that holds aggregations by key values.</p>
<p>For instance, if you want to find the count of each word length occurrence, you can create a <code>Dict</code> like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]

Observable.from_(items) \
    .group_by(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .flat_map(<span class="hljs-keyword">lambda</span> grp:
         grp.count().map(<span class="hljs-keyword">lambda</span> ct: (grp.key, ct))
    ) \
    .to_dict(<span class="hljs-keyword">lambda</span> key_value: key_value[<span class="hljs-number">0</span>], <span class="hljs-keyword">lambda</span> key_value: key_value[<span class="hljs-number">1</span>]) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>{4: 1, 5: 3, 7: 1}
</code></pre>
<p>You can interpret the returned <code>Dict</code> above as “for length 4 there are one occurrences, for length 5 there are 3 occurrences, etc”.</p>
<p><code>group_by()</code> is somewhat abstract but it is a powerful and
 efficient way to perform aggregations on a given key. It also works 
with infinite Observables assuming you use infinite-friendly operators 
on each <code>GroupedObservable</code>. We will use <code>group_by()</code> a few more times in this course.</p>
<h1><a id="Section_VII__Reading_and_Analyzing_data_1015"></a>Section VII - Reading and Analyzing data</h1>
<p>In this chapter we will look over basic ways to reactively read data 
and analyze data from text files, URL’s, and SQL. We will also integrate
 concepts we previously learned to create a reactive word counter that 
runs on a schedule and detects changes to a file.</p>
<p>One catch with using <code>Observable.from_()</code> with a data 
source iterable is it only iterates once, causing multiple Subscribers 
to not receieve data after the first Subscriber. To get around this we 
will use functions to create a new <code>Observable</code> each time we need to subscribe to a data source. A slightly more advanced way to solve this issue is to use <code>Observable.defer()</code> which we will not cover here, but you can read about it in the Appendix.</p>
<p>It is good to leverage functions that return Observables anyway. You 
can accept arguments to build the Observable chain that is returned and 
increase reusability.</p>
<h2><a id="71A__Reading_a_Text_File_1023"></a>7.1A - Reading a Text File</h2>
<p>As stated earlier, anything that is iterable can be turned into an <code>Observable</code> using <code>Observable.from_()</code>. We can emit the lines from a text file in this manner. If I have a raw text file called <code>bbc_news_article.txt</code> in my Python project, I can emit the lines like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_lines</span><span class="hljs-params">(file_name)</span>:</span>
    file = open(file_name)

    <span class="hljs-keyword">return</span> Observable.from_(file) \
        .map(<span class="hljs-keyword">lambda</span> l: l.strip()) \
        .filter(<span class="hljs-keyword">lambda</span> l: l != <span class="hljs-string">""</span>)


read_lines(<span class="hljs-string">"bbc_news_article.txt"</span>).subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Giant waves damage S Asia economy
Governments, aid agencies, insurers and travel firms are among those counting the cost of the massive earthquake and waves that hammered southern Asia.
The worst-hit areas are Sri Lanka, India, Indonesia and Thailand, with at least 23,000 people killed. Early estimates from the World Bank put the amount of aid needed at about $5bn (£2.6bn), similar to the cash offered Central America after Hurricane Mitch. Mitch killed about 10,000 people and caused damage of about $10bn in 1998. World Bank spokesman Damien
...
</code></pre>
<p>I use the <code>map()</code> and <code>filter()</code> operators to strip any leading and trailing whitespace for each line, as well as rid lines that are empty.</p>
<p>We will use this example for a project at the end of this section.</p>
<h2><a id="71B__Reading_a_URL_1056"></a>7.1B - Reading a URL</h2>
<p>You can also read content from the web in a similar manner. This can 
be a powerful way to do web scraping and data wrangling, especially if 
you reactively push multiple URL’s or URL arguments and scrape the 
content off each page. Just be kind and don’t tax somebody’s system!</p>
<p>I saved a simple raw text page of the 50 U.S. states on a Gist page. You can view it with this URL: <a href="https://goo.gl/rIaDyM">https://goo.gl/rIaDyM</a>.</p>
<p>If you want to read the lines off the response, you can do it like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_request</span><span class="hljs-params">(link)</span>:</span>
    f = urlopen(link)

    <span class="hljs-keyword">return</span> Observable.from_(f) \
        .map(<span class="hljs-keyword">lambda</span> s: s.decode(<span class="hljs-string">"utf-8"</span>).strip()) \

read_request(<span class="hljs-string">"https://goo.gl/rIaDyM"</span>) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alabama
Alaska
Arizona
Arkansas
California
Colorado
Connecticut
Delaware
...
</code></pre>
<p>In the map we have to decode the bytes and convert them to UTF-8 
Strings. Then we also clean leading and trailing whitespace with <code>strip()</code>. then finally we print each line.</p>
<h2><a id="72__Reading_a_SQL_Query_1096"></a>7.2 - Reading a SQL Query</h2>
<p>SQLAlchemy is the go-to Python library for SQL querying, and since it
 is iterable it can easily support Rx. In this example, I am using a 
SQLite database file which you can download at <a href="https://goo.gl/9DYXPS">https://goo.gl/9DYXPS</a>. You can also download it on my <a href="https://github.com/thomasnield/oreilly_getting_started_with_sql"><em>Getting Started with SQL</em> GitHub page</a>.</p>
<h3><a id="72A__Emitting_a_query_1102"></a>7.2A - Emitting a query</h3>
<p>When you set up your engine, statement, and connection, you can 
reactively emit each result (which will be a tuple) from a query using <code>Observable.from_()</code>.
 Since a SQL query result set can only be iterated once, it is easiest 
to use a function to create a new one and return it in an <code>Observable</code> each time. That way multiple subscribers can be accommodated easily.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, text
<span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

engine = create_engine(<span class="hljs-string">'sqlite:///C:\\Users\\thoma\\Dropbox\\rexon_metals.db'</span>)
conn = engine.connect()


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_customers</span><span class="hljs-params">()</span>:</span>
    stmt = text(<span class="hljs-string">"SELECT * FROM CUSTOMER"</span>)
    <span class="hljs-keyword">return</span> Observable.from_(conn.execute(stmt))


get_all_customers().subscribe(<span class="hljs-keyword">lambda</span> r: print(r))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>(1, 'LITE Industrial', 'Southwest', '729 Ravine Way', 'Irving', 'TX', 75014)
(2, 'Rex Tooling Inc', 'Southwest', '6129 Collie Blvd', 'Dallas', 'TX', 75201)
(3, 'Re-Barre Construction', 'Southwest', '9043 Windy Dr', 'Irving', 'TX', 75032)
(4, 'Prairie Construction', 'Southwest', '264 Long Rd', 'Moore', 'OK', 62104)
(5, 'Marsh Lane Metal Works', 'Southeast', '9143 Marsh Ln', 'Avondale', 'LA', 79782)
</code></pre>
<h3><a id="72B__Merging_multiple_queries_1133"></a>7.2B - Merging multiple queries</h3>
<p>You can create some powerful reactive patterns when working with 
databases. For instance, say you wanted to query for customers with ID’s
 1, 3, and 5. Of course you can do this in raw SQL like so:</p>
<pre><code class="language-sql"><span class="hljs-operator"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> CUSTOMER <span class="hljs-keyword">WHERE</span> CUSTOMER_ID <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)
</span></code></pre>
<p>However, let’s leverage Rx to keep our API simple and minimize the number of query functions it needs.</p>
<p>You can create a single <code>customer_for_id()</code> function that returns an <code>Observable</code> emitting a customer for a given <code>customer_id</code>. You can compose it into a reactive chain by using <code>merge_all()</code> or <code>flat_map()</code>. Do this by emitting the desired ID’s, mapping them to the <code>customer_for_id()</code>, and then calling <code>merge_all()</code> to consolidate the results from all three queries.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, text
<span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

engine = create_engine(<span class="hljs-string">'sqlite:///C:\\Users\\thoma\\Dropbox\\rexon_metals.db'</span>)
conn = engine.connect()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_customers</span><span class="hljs-params">()</span>:</span>
    stmt = text(<span class="hljs-string">"SELECT * FROM CUSTOMER"</span>)
    <span class="hljs-keyword">return</span> Observable.from_(conn.execute(stmt))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">customer_for_id</span><span class="hljs-params">(customer_id)</span>:</span>
    stmt = text(<span class="hljs-string">"SELECT * FROM CUSTOMER WHERE CUSTOMER_ID = :id"</span>)
    <span class="hljs-keyword">return</span> Observable.from_(conn.execute(stmt, id=customer_id))

<span class="hljs-comment"># Query customers with IDs 1, 3, and 5</span>
Observable.from_([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) \
    .flat_map(<span class="hljs-keyword">lambda</span> id: customer_for_id(id)) \
    .subscribe(<span class="hljs-keyword">lambda</span> r: print(r))

</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>(1, 'LITE Industrial', 'Southwest', '729 Ravine Way', 'Irving', 'TX', 75014)
(3, 'Re-Barre Construction', 'Southwest', '9043 Windy Dr', 'Irving', 'TX', 75032)
(5, 'Marsh Lane Metal Works', 'Southeast', '9143 Marsh Ln', 'Avondale', 'LA', 79782)
</code></pre>
<p>You can also use Rx to write data to databases using operators or 
Subscribers. This is beyond the scope of this course, but just remember 
that any iterable can be turned into an <code>Observable</code>!</p>
<h2><a id="73__A_Scheduled_Reactive_Word_Counter_1178"></a>7.3 - A Scheduled Reactive Word Counter</h2>
<p>Let’s apply everything we have learned so far to create a reactive word counter process.</p>
<h3><a id="73A__Emitting_words_from_a_text_file_1183"></a>7.3A - Emitting words from a text file</h3>
<p>Let’s start by creating a function that returns an <code>Observable</code> emitting and cleaning the words in a text file, ridding punctuation, empty lines, and making all words lower case.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> re


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">words_from_file</span><span class="hljs-params">(file_name)</span>:</span>
    file = open(file_name)

    <span class="hljs-comment"># parse, clean, and push words in text file</span>
    <span class="hljs-keyword">return</span> Observable.from_(file) \
        .flat_map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split())) \
        .map(<span class="hljs-keyword">lambda</span> w: re.sub(<span class="hljs-string">r'[^\w]'</span>, <span class="hljs-string">''</span>, w)) \
        .filter(<span class="hljs-keyword">lambda</span> w: w != <span class="hljs-string">""</span>) \
        .map(<span class="hljs-keyword">lambda</span> w: w.lower())

article_file = <span class="hljs-string">"bbc_news_article.txt"</span>
words_from_file(article_file).subscribe(<span class="hljs-keyword">lambda</span> w: print(w))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>giant
waves
damage
governments
s
aid
asia
agencies
the
economy
...
</code></pre>
<h3><a id="73B__Counting_Word_Occurrences_1222"></a>7.3B - Counting Word Occurrences</h3>
<p>Let’s create another function called <code>word_counter()</code>. It will leverage the existing <code>words_from_file()</code> then use <code>group_by()</code> to count the word occurrances, then tuple the word with the count.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> re


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">words_from_file</span><span class="hljs-params">(file_name)</span>:</span>
    file = open(file_name)

    <span class="hljs-comment"># parse, clean, and push words in text file</span>
    <span class="hljs-keyword">return</span> Observable.from_(file) \
        .flat_map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split())) \
        .map(<span class="hljs-keyword">lambda</span> w: re.sub(<span class="hljs-string">r'[^\w\s]'</span>, <span class="hljs-string">''</span>, w)) \
        .filter(<span class="hljs-keyword">lambda</span> w: w != <span class="hljs-string">""</span>) \
        .map(<span class="hljs-keyword">lambda</span> w: w.lower()) \



<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">word_counter</span><span class="hljs-params">(file_name)</span>:</span>

    <span class="hljs-comment"># count words using `group_by()`</span>
    <span class="hljs-comment"># tuple the word with the count</span>
    <span class="hljs-keyword">return</span> words_from_file(file_name) \
        .group_by(<span class="hljs-keyword">lambda</span> word: word) \
        .flat_map(<span class="hljs-keyword">lambda</span> grp: grp.count().map(<span class="hljs-keyword">lambda</span> ct: (grp.key, ct)))

article_file = <span class="hljs-string">"bbc_news_article.txt"</span>
word_counter(article_file).subscribe(<span class="hljs-keyword">lambda</span> w: print(w))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>('giant', 1)
('waves', 3)
('damage', 6)
('governments', 3)
('s', 1)
('aid', 10)
('asia', 6)
('agencies', 3)
('the', 78)
('economy', 1)
...
</code></pre>
<h2><a id="73C__Scheduling_the_Word_Count_And_Notifying_of_Changes_1271"></a>7.3C - Scheduling the Word Count And Notifying of Changes</h2>
<p>Finally, let’s schedule this word count to occur every 3 seconds and collect them into a <code>Dict</code>. We can use <code>distinct_until_changed()</code> to only emit <code>Dict</code> items that have changed due to the text file being edited.</p>
<pre><code class="language-python"><span class="hljs-comment"># Schedules a reactive process that counts the words in a text file every three seconds,</span>
<span class="hljs-comment"># but only prints it as a dict if it has changed</span>

<span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> re


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">words_from_file</span><span class="hljs-params">(file_name)</span>:</span>
    file = open(file_name)

    <span class="hljs-comment"># parse, clean, and push words in text file</span>
    <span class="hljs-keyword">return</span> Observable.from_(file) \
        .flat_map(<span class="hljs-keyword">lambda</span> s: Observable.from_(s.split())) \
        .map(<span class="hljs-keyword">lambda</span> w: re.sub(<span class="hljs-string">r'[^\w\s]'</span>, <span class="hljs-string">''</span>, w)) \
        .filter(<span class="hljs-keyword">lambda</span> w: w != <span class="hljs-string">""</span>) \
        .map(<span class="hljs-keyword">lambda</span> w: w.lower()) \



<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">word_counter</span><span class="hljs-params">(file_name)</span>:</span>

    <span class="hljs-comment"># count words using `group_by()`</span>
    <span class="hljs-comment"># tuple the word with the count</span>
    <span class="hljs-keyword">return</span> words_from_file(file_name) \
        .group_by(<span class="hljs-keyword">lambda</span> word: word) \
        .flat_map(<span class="hljs-keyword">lambda</span> grp: grp.count().map(<span class="hljs-keyword">lambda</span> ct: (grp.key, ct)))


<span class="hljs-comment"># composes the above word_counter() into a dict</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">word_counter_as_dict</span><span class="hljs-params">(file_name)</span>:</span>
    <span class="hljs-keyword">return</span> word_counter(file_name).to_dict(<span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">0</span>], <span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">1</span>])


<span class="hljs-comment"># Schedule to create a word count dict every three seconds an article</span>
<span class="hljs-comment"># But only re-print if text is edited and word counts change</span>

article_file = <span class="hljs-string">"bbc_news_article.txt"</span>

<span class="hljs-comment"># create a dict every three seconds, but only push if it changed</span>
Observable.interval(<span class="hljs-number">3000</span>) \
    .flat_map(<span class="hljs-keyword">lambda</span> i: word_counter_as_dict(article_file))
    .distinct_until_changed() \
    .subscribe(<span class="hljs-keyword">lambda</span> word_ct_dict: print(word_ct_dict))

<span class="hljs-comment"># Keep alive until user presses any key</span>
input(<span class="hljs-string">"Starting, press any key to quit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Starting, press any key to quit
{'a': 7, 'governments': 3, 'first': 1, 'getting': 1, 'offered': 1, ...
</code></pre>
<p>Every time the file is edited and words are added, modified, or removed, it should push a new <code>Dict</code>
 reflecting these changes. This can be helpful to run a report on a 
schedule, and you can only emit a new report to an output if the data 
has changed.</p>
<p>Ideally, it is better to hook onto the change event itself rather 
than running a potentially expensive process every 3 seconds. We will 
learn how to do this with Twitter in the next section.</p>
<blockquote>
<p>If you want to see an intensive reactive data analysis example, see my <a href="https://goo.gl/NO0Q4P">social media example on Gist</a></p>
</blockquote>
<h1><a id="Section_VIII__Hot_Observables_1336"></a>Section VIII - Hot Observables</h1>
<p>In this section we will learn how to create an <code>Observable</code> emitting Tweets for a set of topics. We will wrap an <code>Observable.create()</code> around the Tweepy API. But first, let’s cover multicasting.</p>
<h2><a id="81A__Creating_a_ConnectableObservable_1340"></a>8.1A - Creating a <code>ConnectableObservable</code></h2>
<p>Remember how cold Observables will replay data to each Subscriber like a music CD?</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>])

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Subscriber 1: Alpha
Subscriber 1: Beta
Subscriber 1: Gamma
Subscriber 1: Delta
Subscriber 1: Epsilon
Subscriber 2: Alpha
Subscriber 2: Beta
Subscriber 2: Gamma
Subscriber 2: Delta
Subscriber 2: Epsilon
</code></pre>
<p>This is often what we want so no data is missed for each Subscriber. 
But there are times we will want to force cold Observables to become hot
 Observables. We can do this by calling <code>publish()</code> which will return a <code>ConnectableObservable</code>. Then we can subscribe our Subscribers to it, then call <code>connect()</code> to fire emissions to all Subscribers at once.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source = Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]).publish()

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))

source.connect()
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Subscriber 1: Alpha
Subscriber 2: Alpha
Subscriber 1: Beta
Subscriber 2: Beta
Subscriber 1: Gamma
Subscriber 2: Gamma
Subscriber 1: Delta
Subscriber 2: Delta
Subscriber 1: Epsilon
Subscriber 2: Epsilon
</code></pre>
<p>This is known as multicasting. Notice how the emissions are now 
interleaved? This is because each emission is going to both subscribers.
 This is helpful if “replaying” the data is expensive or we just simply 
want all Subscribers to get the emissions simultaneously.</p>
<h2><a id="81B__Sharing_an_Interval_Observable_1398"></a>8.1B - Sharing an Interval Observable</h2>
<p><code>Observable.interval()</code> is actually a cold Observable too.
 If one Subscriber subscribes to it, and 5 seconds later another 
Subscriber comes in, that second subscriber will receive its own 
emissions that “start over”.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> time

source = Observable.interval(<span class="hljs-number">1000</span>)

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))

<span class="hljs-comment"># sleep 5 seconds, then add another subscriber</span>
time.sleep(<span class="hljs-number">5</span>)
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))

input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Subscriber 1: 0
Subscriber 1: 1
Subscriber 1: 2
Subscriber 1: 3
Press any key to exit
Subscriber 1: 4
Subscriber 2: 0
Subscriber 1: 5
Subscriber 2: 1
Subscriber 1: 6
Subscriber 2: 2
Subscriber 1: 7
Subscriber 2: 3

</code></pre>
<p>Subscriber 2 starts at <code>0</code> while Subscriber 2 is already at <code>4</code>. If we want both to be on the same timer, we can use <code>publish()</code> to create a <code>ConnectableObservable</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> time

source = Observable.interval(<span class="hljs-number">1000</span>).publish()

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))
source.connect()

<span class="hljs-comment"># sleep 5 seconds, then add another subscriber</span>
time.sleep(<span class="hljs-number">5</span>)
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))

input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Subscriber 1: 0
Subscriber 1: 1
Subscriber 1: 2
Subscriber 1: 3
Press any key to exit
Subscriber 1: 4
Subscriber 2: 4
Subscriber 1: 5
Subscriber 2: 5
</code></pre>
<h2><a id="81C__Autoconnecting_1469"></a>8.1C - Autoconnecting</h2>
<p>We can have our <code>ConnectableObservable</code> automatically <code>connect()</code> itself when it gets a Subscriber by calling <code>ref_count()</code> on it.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">import</span> time

source = Observable.interval(<span class="hljs-number">1000</span>).publish().ref_count()

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 1: {0}"</span>.format(s)))

<span class="hljs-comment"># sleep 5 seconds, then add another subscriber</span>
time.sleep(<span class="hljs-number">5</span>)
source.subscribe(<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Subscriber 2: {0}"</span>.format(s)))

input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p>You can also call an alias for <code>publish().ref_count()</code> by calling <code>share()</code> instead.</p>
<pre><code class="language-python">source = Observable.interval(<span class="hljs-number">1000</span>).share()
</code></pre>
<p>Again, multicasting is helpful when you want all Subscribers to receive the same emissions simultaneously<br>
and prevent redundant, expensive work for each Subscriber.</p>
<h2><a id="82__Querying_Live_Twitter_Feeds_1500"></a>8.2 - Querying Live Twitter Feeds</h2>
<p>You can use <code>Observable.create()</code> to wrangle and analyze a live Twitter feed.</p>
<p>You will need to create your own application and access keys/tokens at <a href="https://apps.twitter.com/">https://apps.twitter.com</a>.</p>
<p>If we want to query a live stream of Tweets pertaining to the topics of “Britain” or “France”, we can do it like this:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> tweepy.streaming <span class="hljs-keyword">import</span> StreamListener
<span class="hljs-keyword">from</span> tweepy <span class="hljs-keyword">import</span> OAuthHandler
<span class="hljs-keyword">from</span> tweepy <span class="hljs-keyword">import</span> Stream
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

<span class="hljs-comment"># Variables that contains the user credentials to access Twitter API</span>
access_token = <span class="hljs-string">"PUT YOURS HERE"</span>
access_token_secret = <span class="hljs-string">"PUT YOURS HERE"</span>
consumer_key = <span class="hljs-string">"PUT YOURS HERE"</span>
consumer_secret = <span class="hljs-string">"PUT YOURS HERE"</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tweets_for</span><span class="hljs-params">(topics)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">observe_tweets</span><span class="hljs-params">(observer)</span>:</span>
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TweetListener</span><span class="hljs-params">(StreamListener)</span>:</span>
            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_data</span><span class="hljs-params">(self, data)</span>:</span>
                observer.on_next(data)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_error</span><span class="hljs-params">(self, status)</span>:</span>
                observer.on_error(status)

        <span class="hljs-comment"># This handles Twitter authetification and the connection to Twitter Streaming API</span>
        l = TweetListener()
        auth = OAuthHandler(consumer_key, consumer_secret)
        auth.set_access_token(access_token, access_token_secret)
        stream = Stream(auth, l)
        stream.filter(track=topics)

    <span class="hljs-keyword">return</span> Observable.create(observe_tweets).share()


topics = [<span class="hljs-string">'Britain'</span>, <span class="hljs-string">'France'</span>]

tweets_for(topics) \
    .map(<span class="hljs-keyword">lambda</span> d: json.loads(d)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> s: print(s), on_error=<span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<h1><a id="IX__Concurrency_1549"></a>IX - Concurrency</h1>
<p>(Refer to slides to cover concurrency concepts).</p>
<h2><a id="91__Using_subscribe_on_1553"></a>9.1 - Using <code>subscribe_on()</code></h2>
<h2><a id="91A__Two_LongRunning_Processes_1555"></a>9.1A - Two Long-Running Processes</h2>
<p>We will not dive too deep into concurrency topics, but we will learn enough to make it useful and speed up slow processes.</p>
<blockquote>
<p>Keep in mind your output may be different than mine, because 
concurrency tends to shuffle emissions of multiple sources. Output is 
almost never deterministic when multiple threads are doing work 
simultaneously and being merged.</p>
</blockquote>
<p>Below, we create two Observables we will call “Process 1” and 
“Process 2”. The first Observable is emitting five strings and the other
 emits numbers in a range.  These Observables will fire quickly when 
subscribed to, but concurrency is more useful and apparent with 
long-running tasks. To emulate long-running expensive processes, we will
 need to exaggerate and slow down emissions. We can use a <code>intense_calculation()</code>
 function that sleeps for a short random duration (between 0.5 to 2.0 
seconds) before returning the value it was given. Then we can use this 
in a <code>map()</code> operator for each <code>Observable</code>.</p>
<p>We will use <code>current_thread().name</code> to identify the thread that is calling each <code>on_next()</code> in the <code>Subscriber</code>. Python will label each thread it creates consecutively as “Thread-1”, “Thread-2”, “Thread-3”, etc.</p>
<p>Before “Process 2” can start, it must wait for “Process 1” to call <code>on_completed()</code> because by default both are on the <code>ImmediateScheduler</code>. This scheduler uses the same <code>MainThread</code> that runs our Python program.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># Create Process 1</span>
Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"PROCESS 1: {0} {1}"</span>.format(current_thread().name, s)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 1 done!"</span>))

<span class="hljs-comment"># Create Process 2</span>
Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"PROCESS 2: {0} {1}"</span>.format(current_thread().name, i)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 2 done!"</span>))

input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT (May not match yours):</strong></p>
<pre><code>PROCESS 1: MainThread Alpha
PROCESS 1: MainThread Beta
PROCESS 1: MainThread Gamma
PROCESS 1: MainThread Delta
PROCESS 1: MainThread Epsilon
PROCESS 1 done!
PROCESS 2: MainThread 1
PROCESS 2: MainThread 2
PROCESS 2: MainThread 3
PROCESS 2: MainThread 4
PROCESS 2: MainThread 5
PROCESS 2: MainThread 6
PROCESS 2: MainThread 7
PROCESS 2: MainThread 8
PROCESS 2: MainThread 9
PROCESS 2: MainThread 10
PROCESS 2 done!
</code></pre>
<h2><a id="91B__Kicking_off_both_processes_simultaneously_1617"></a>9.1B - Kicking off both processes simultaneously</h2>
<p>This would go much faster if we kick off both “Process 1” and 
“Process 2” simultaneously. We can kick off the Subscription in “Process
 1” and then immediately move on to kicking off “Process 2”. We will 
kick off both of their subscriptions simultaneously.</p>
<p>In advance, we can create a <code>ThreadPoolScheduler</code> that holds a number of threads equaling the <em>number of CPU’s on your computer</em> + 1. If your computer has 4 cores, the <code>ThreadPoolScheduler</code>
 will have 5 threads.  The reason for the extra thread is to utilize any
 idle time of the other threads. To make the Observables work on this <code>ThreadPoolScheduler</code>, we can pass it to a <code>subscribe_on()</code> operator anywhere in the chain. The <code>subscribe_on()</code>, no matter where it is in the chain, will instruct the source Observable what thread to push items on.</p>
<blockquote>
<p>You are welcome to experiment and specify your own arbitrary number 
of threads. Just keep in mind there will be a point of diminishing 
return.</p>
</blockquote>
<p>The code below will execute all the above:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> rx.concurrency <span class="hljs-keyword">import</span> ThreadPoolScheduler
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># calculate number of CPU's and add 1, then create a ThreadPoolScheduler with that number of threads</span>
optimal_thread_count = multiprocessing.cpu_count() + <span class="hljs-number">1</span>
pool_scheduler = ThreadPoolScheduler(optimal_thread_count)

print(<span class="hljs-string">"We are using {0} threads"</span>.format(optimal_thread_count))

<span class="hljs-comment"># Create Process 1</span>
Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe_on(pool_scheduler) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"PROCESS 1: {0} {1}"</span>.format(current_thread().name, s)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 1 done!"</span>))

<span class="hljs-comment"># Create Process 2</span>
Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe_on(pool_scheduler) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"PROCESS 2: {0} {1}"</span>.format(current_thread().name, i)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 2 done!"</span>))

input(<span class="hljs-string">"Press any key to exit\n"</span>)

</code></pre>
<p><strong>OUTPUT (May not match yours):</strong></p>
<pre><code>PROCESS 1: Thread-1 Alpha
PROCESS 2: Thread-2 1
PROCESS 1: Thread-1 Beta
PROCESS 1: Thread-1 Gamma
PROCESS 2: Thread-2 2
PROCESS 2: Thread-2 3
PROCESS 1: Thread-1 Delta
PROCESS 2: Thread-2 4
PROCESS 1: Thread-1 Epsilon
PROCESS 1 done!
PROCESS 2: Thread-2 5
PROCESS 2: Thread-2 6
PROCESS 2: Thread-2 7
PROCESS 2: Thread-2 8
PROCESS 2: Thread-2 9
PROCESS 2: Thread-2 10
PROCESS 2 done!
</code></pre>
<p>We use the <code>input()</code> function to hold the <code>MainThread</code>
 and keep the application alive until a key is pressed, allowing the 
Observables to fire. Notice how the emissions between Process 1 and 
Process 2 are interleaved, indicating they are both working at the same 
time. If we did not have the <code>subscribe_on()</code> calls, “Process 1” would have to finish before “Process 2” can start, because they both would use the default <code>ImmediateScheduler</code> as shown earlier.</p>
<p>Notice also that “Process 1” requested a thread from our <code>ThreadPoolScheduler</code> and got <code>Thread-1</code>, and “Process 2” got <code>Thread 2</code>. They both will continue to use these threads until <code>on_completed()</code> is called on their Subscribers. Then the threads will be given back to the <code>ThreadPoolScheduler</code> so they can be used again later.</p>
<h2><a id="92__Using_observe_on_to_redirect_in_the_middle_of_the_chain_1692"></a>9.2 - Using <code>observe_on()</code> to redirect in the middle of the chain</h2>
<p>Not all source Observables will respect a <code>subscribe_on()</code> you specify. This is especially true for time-driven sources like <code>Observable.interval()</code> which will use the <code>TimeoutScheduler</code> and effectively ignore any <code>subscribe_on()</code>
 you try to call. However, although you cannot instruct the source to 
emit on a different scheduler, you can specify a different scheduler to 
be used <em>at a certain point</em> in the <code>Observable</code> chain by using <code>observe_on()</code>.</p>
<p>Let’s create a third process called “Process 3”. The source will be an <code>Observable.interval()</code> which will emit on the <code>TimeoutScheduler</code>. After each emitted number is multiplied by 100, the emission is then moved to the <code>ThreadPoolScheduler</code> via the <code>observe_on()</code> operator. This means for the remaining operators, the emissions will be passed on the <code>ThreadPoolScheduler</code>. Unlike <code>subscribe_on()</code>, the placement of <code>observe_on()</code> does matter as it will redirect to a different executor <em>at that point</em> in the chain.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> rx.concurrency <span class="hljs-keyword">import</span> ThreadPoolScheduler
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># calculate number of CPU's and add 1, then create a ThreadPoolScheduler with that number of threads</span>
optimal_thread_count = multiprocessing.cpu_count() + <span class="hljs-number">1</span>
pool_scheduler = ThreadPoolScheduler(optimal_thread_count)

<span class="hljs-comment"># Create Process 1</span>
Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe_on(pool_scheduler) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"PROCESS 1: {0} {1}"</span>.format(current_thread().name, s)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
              on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 1 done!"</span>))

<span class="hljs-comment"># Create Process 2</span>
Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe_on(pool_scheduler) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"PROCESS 2: {0} {1}"</span>.format(current_thread().name, i)), on_error=<span class="hljs-keyword">lambda</span> e: print(e), on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 2 done!"</span>))

<span class="hljs-comment"># Create Process 3, which is infinite</span>
Observable.interval(<span class="hljs-number">1000</span>) \
    .map(<span class="hljs-keyword">lambda</span> i: i * <span class="hljs-number">100</span>) \
    .observe_on(pool_scheduler) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"PROCESS 3: {0} {1}"</span>.format(current_thread().name, i)), on_error=<span class="hljs-keyword">lambda</span> e: print(e))

input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT (May not match yours):</strong></p>
<pre><code>PROCESS 2: Thread-2 1
PROCESS 1: Thread-1 Alpha
PROCESS 1: Thread-1 Beta
PROCESS 3: Thread-4 0
PROCESS 2: Thread-2 2
PROCESS 1: Thread-1 Gamma
PROCESS 3: Thread-4 100
PROCESS 1: Thread-1 Delta
PROCESS 2: Thread-2 3
PROCESS 3: Thread-6 200
PROCESS 1: Thread-1 Epsilon
PROCESS 1 done!
PROCESS 3: Thread-13 300
PROCESS 2: Thread-2 4
PROCESS 3: Thread-15 400
PROCESS 2: Thread-2 5
PROCESS 3: Thread-4 500
PROCESS 2: Thread-2 6
PROCESS 3: Thread-4 600
PROCESS 2: Thread-2 7
PROCESS 3: Thread-4 700
PROCESS 2: Thread-2 8
PROCESS 3: Thread-4 800
PROCESS 2: Thread-2 9
PROCESS 3: Thread-4 900
PROCESS 3: Thread-4 1000
PROCESS 2: Thread-2 10
PROCESS 2 done!
PROCESS 3: Thread-4 1100
PROCESS 3: Thread-4 1200
PROCESS 3: Thread-4 1300
PROCESS 3: Thread-4 1400
...
</code></pre>
<p>Unlike <code>subscribe_on()</code>, the <code>observe_on()</code> may use a different thread for each emission rather than reserving one thread for all emissions. You can use as many <code>observe_on()</code> calls as you like in an <code>Observable</code> chain to redirect emissions to different thread pools at different points in the chain. But you can only have one <code>subscribe_on()</code>.</p>
<blockquote>
<p>You can use the <code>do_action()</code> to essentially put 
Subscribers in the middle of the Observable chain, often for debugging 
purposes. This can be helpful to print the current thread at different 
points in the <code>Observable</code> chain. Refer to the Appendix to learn more.</p>
</blockquote>
<h1><a id="93__Parallelization_1781"></a>9.3 - Parallelization</h1>
<p>An <code>Observable</code> will only process one item at a time. However, we can use a <code>subscribe_on()</code> or an <code>observe_on()</code> in a <code>flat_map()</code> and do multiple operations in parallel <em>within</em> that <code>flat_map()</code>.</p>
<p>For instance, say I have 10 Strings I need to process. Because our <code>intense_calculation()</code>  will take 0.5 to 2.0 seconds to process each emission, this could take up to 20 seconds.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> rx.concurrency <span class="hljs-keyword">import</span> ThreadPoolScheduler
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># Create Parallel Process</span>
Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>,<span class="hljs-string">"Zeta"</span>,<span class="hljs-string">"Eta"</span>,<span class="hljs-string">"Theta"</span>,<span class="hljs-string">"Iota"</span>,<span class="hljs-string">"Kappa"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"{0} {1}"</span>.format(current_thread().name, s)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 1 done!"</span>))


input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p>This would go much faster if we processed multiple emissions at a time rather than one at a time. Let’s set</p>
<p>My computer has 8 cores, but let’s use Python to count the number of cores dynamically. Let’s set a <code>ThreadPoolScheduler</code>
 to have that many threads (plus one) according to our rough optimal 
formula. Rather than process 1 item at a time, I can now process 9 at a 
time which will yield a much faster completion. I just need to make sure
 the expensive operators happen within a <code>flat_map()</code>, starting with that single emission wrapped in an <code>Observable.just()</code> and scheduled using <code>subscribe_on()</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> rx.concurrency <span class="hljs-keyword">import</span> ThreadPoolScheduler
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>,<span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># calculate number of CPU's and add 1, then create a ThreadPoolScheduler with that number of threads</span>
optimal_thread_count = multiprocessing.cpu_count() + <span class="hljs-number">1</span>
pool_scheduler = ThreadPoolScheduler(optimal_thread_count)

<span class="hljs-comment"># Create Parallel Process</span>
Observable.from_([<span class="hljs-string">"Alpha"</span>,<span class="hljs-string">"Beta"</span>,<span class="hljs-string">"Gamma"</span>,<span class="hljs-string">"Delta"</span>,<span class="hljs-string">"Epsilon"</span>,<span class="hljs-string">"Zeta"</span>,<span class="hljs-string">"Eta"</span>,<span class="hljs-string">"Theta"</span>,<span class="hljs-string">"Iota"</span>,<span class="hljs-string">"Kappa"</span>]) \
    .flat_map(<span class="hljs-keyword">lambda</span> s:
        Observable.just(s).subscribe_on(pool_scheduler).map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s))
    ) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"{0} {1}"</span>.format(current_thread().name, i)),
               on_error=<span class="hljs-keyword">lambda</span> e: print(e),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"PROCESS 1 done!"</span>))


input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Press any key to exit
Thread-4 Delta
Thread-6 Zeta
Thread-1 Alpha
Thread-2 Beta
Thread-9 Iota
Thread-3 Gamma
Thread-8 Theta
Thread-4 Kappa
Thread-7 Eta
Thread-5 Epsilon
PROCESS done!
</code></pre>
<p>Now this takes less than 3 seconds! Of course the 10 items are now 
racing each other and complete in a random order. Only 9 threads are 
available, thus a 10th item must wait for one of the first 9 to 
complete. It looks like this item was <code>Kappa</code> which received <code>Thread-4</code> from <code>Delta</code> after it was done.</p>
<p>Parallelization using <code>flat_map()</code> (or <code>merge_all()</code>) can greatly increase performance if each emission must go through an expensive operation. Just wrap that emission into an  <code>Observable.just()</code>, schedule it with <code>subscribe_on()</code> or <code>observe_on()</code> (preferably <code>subscribe_on()</code> if possible), and then make all the expensive operations happen inside the <code>flat_map()</code>.</p>
<p>The reason each emission must be broken into its own <code>Observable</code> is because an <code>Observable</code>
 is sequential and cannot be parallelized. But you can take multiple 
Observables and merge them into a single Observable, even if they are 
working on a different threads. The merged Observable will only push out
 items on one thread, but the items inside <code>flat_map()</code> can process in parallel.</p>
<h1><a id="94__Redirecting_Work_with_switch_map_1865"></a>9.4 - Redirecting Work with <code>switch_map()</code></h1>
<p>Imagine you have an <code>Observable</code> and you use <code>flat_map()</code> to yield a emissions from another <code>Observable</code>. However, say you wanted to <em>only</em> puruse the <code>Observable</code> for the latest emission, and kill any previous Observables to stop their emissions coming out of <code>flat_map()</code>.</p>
<p>You can achieve this with <code>switch_map()</code>. It operates much like a <code>flat_map()</code>,
 but will only fire items for the latest emission. All previous 
Observables derived from previous emissions will be unsubscribed.</p>
<p>This example is slightly contrived, but let’s say we have a finite <code>Observable</code> emitting Strings. We want an <code>Observable.interval()</code> to emit every 6 seconds, and have each emission flat map to our <code>Observable</code> of strings which are artificially slowed by <code>intense_calculation()</code>. But instead of using <code>flat_map()</code>, we can use <code>switch_map()</code> to only chase after the latest <code>Observable</code> created off each interval emission and unsubscribe previous ones.</p>
<p>We also need to parallelize using <code>subscribe_on()</code> so each Observable within the <code>switch_map()</code> happens on a different thread.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable
<span class="hljs-keyword">from</span> rx.concurrency <span class="hljs-keyword">import</span> ThreadPoolScheduler
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> current_thread
<span class="hljs-keyword">import</span> multiprocessing, time, random


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intense_calculation</span><span class="hljs-params">(value)</span>:</span>
    <span class="hljs-comment"># sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation</span>
    time.sleep(random.randint(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>) * <span class="hljs-number">.1</span>)
    <span class="hljs-keyword">return</span> value

<span class="hljs-comment"># calculate number of CPU's and add 1, then create a ThreadPoolScheduler with that number of threads</span>
optimal_thread_count = multiprocessing.cpu_count() + <span class="hljs-number">1</span>
pool_scheduler = ThreadPoolScheduler(optimal_thread_count)

strings = Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>, <span class="hljs-string">"Zeta"</span>, <span class="hljs-string">"Eta"</span>, <span class="hljs-string">"Theta"</span>, <span class="hljs-string">"Iota"</span>, <span class="hljs-string">"Kappa"</span>])

Observable.interval(<span class="hljs-number">6000</span>) \
    .switch_map(<span class="hljs-keyword">lambda</span> i: strings.map(<span class="hljs-keyword">lambda</span> s: intense_calculation(s)).subscribe_on(pool_scheduler)) \
    .subscribe(on_next = <span class="hljs-keyword">lambda</span> s: print(<span class="hljs-string">"Received {0} on {1}"</span>.format(s, current_thread().name)),
               on_error = <span class="hljs-keyword">lambda</span> e: print(e))


input(<span class="hljs-string">"Press any key to exit\n"</span>)
</code></pre>
<p><strong>OUTPUT (May Vary):</strong></p>
<pre><code>Press any key to exit
Received Alpha on Thread-2
Received Beta on Thread-2
Received Gamma on Thread-2
Received Delta on Thread-2
Received Alpha on Thread-4
Received Beta on Thread-4
Received Gamma on Thread-4
Received Alpha on Thread-6
Received Beta on Thread-6
Received Gamma on Thread-6
Received Delta on Thread-6
Received Epsilon on Thread-6
Received Alpha on Thread-2
...
</code></pre>
<p>Using <code>switch_map()</code> is a convenient way to cancel current
 work when new work comes in, rather than queuing up work. This is 
desirable if you are only concerned with the latest data or want to 
cancel obsolete processing. If you are scraping web data on a schedule 
using <code>Observable.interval()</code>, but a scrape instance takes too long and a new scrape requests comes in, you can cancel that scrape and start the next one.</p>
<h1><a id="Appendix_1925"></a>Appendix</h1>
<h2><a id="1__Deferred_Observables_1927"></a>1 - Deferred Observables</h2>
<p>A behavior to be aware of with <code>Observable.from_()</code> and other functions that create Observables is they may not reflect changes that happen to their sources, such as a <code>List</code>.</p>
<p>If we build an <code>Observable</code> off a <code>List</code>, <code>subscribe</code> to it, add “Delta”, then <code>subscribe()</code> again, we will not see that “Delta” item emitted.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>]
source = Observable.from_(items)

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

print(<span class="hljs-string">"\nAdding Delta!\n"</span>)
items.append(<span class="hljs-string">"Delta"</span>)

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Beta
Gamma

Adding Delta!

Alpha
Beta
Gamma
Delta
</code></pre>
<p>Using <code>Observable.defer()</code> allows you to create a new <code>Observable</code> from scratch each time it is subscribed, and therefore capturing anything that might have changed about its source.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

items = [<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>]
source = Observable.defer(<span class="hljs-keyword">lambda</span>: Observable.from_(items))

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

print(<span class="hljs-string">"\nAdding Delta!\n"</span>)
items.append(<span class="hljs-string">"Delta"</span>)

source.subscribe(<span class="hljs-keyword">lambda</span> s: print(s))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Alpha
Beta
Gamma

Adding Delta!

Alpha
Beta
Gamma
Delta
</code></pre>
<p>The lambda argument ensures the <code>Observable</code> source 
declaration is rebuilt each time it is subscribed to. This is especially
 helpful to use with data sources that can only be iterated once, as 
opposed to calling a helper function for each Subscriber (this was 
covered in Section VII):</p>
<pre><code class="language-python">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_customers</span><span class="hljs-params">()</span>:</span>
    stmt = text(<span class="hljs-string">"SELECT * FROM CUSTOMER"</span>)
    <span class="hljs-keyword">return</span> Observable.from_(conn.execute(stmt))
</code></pre>
<p>We can actually create an <code>Obserable</code> that is truly reusable for multiple Subscribers.</p>
<pre><code class="language-python">stmt = text(<span class="hljs-string">"SELECT * FROM CUSTOMER"</span>)

<span class="hljs-comment"># Will suppport multiple subscribers and coldly replay to each one</span>
all_customers =  Observable.defer(<span class="hljs-keyword">lambda</span>: Observable.from_(conn.execute(stmt)))
</code></pre>
<h2><a id="2__Debugging_with_do_action_2012"></a>2 - Debugging with <code>do_action()</code></h2>
<p>A helpful operator that provides insight into any point in the <code>Observable</code> chain is the <code>do_action()</code>. This essentially allows us to insert a <code>Subscriber</code> after any operator we want, and pass one or more of <code>on_next()</code>, <code>on_completed()</code>, and <code>on_error()</code> actions.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-string">"Alpha"</span>, <span class="hljs-string">"Beta"</span>, <span class="hljs-string">"Gamma"</span>, <span class="hljs-string">"Delta"</span>, <span class="hljs-string">"Epsilon"</span>]) \
    .map(<span class="hljs-keyword">lambda</span> s: len(s)) \
    .do_action(on_next=<span class="hljs-keyword">lambda</span> i: print(<span class="hljs-string">"Receiving {0} from map()"</span>.format(i)),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"map() is done!"</span>)) \
    .to_list() \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> l: print(<span class="hljs-string">"Subscriber received {0}"</span>.format(l)),
               on_completed=<span class="hljs-keyword">lambda</span>: print(<span class="hljs-string">"Subscriber done!"</span>))

</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Receiving 5 from map()
Receiving 4 from map()
Receiving 5 from map()
Receiving 5 from map()
Receiving 7 from map()
map() is done!
Subscriber received [5, 4, 5, 5, 7]
Subscriber done!
</code></pre>
<p>Above, we declare a <code>do_action</code> right after the <code>map()</code> operation emitting the lengths. We print each length emission before it goes to the <code>to_list()</code>. Finally, <code>on_completed</code> is called and prints a notification that <code>map()</code> is not giving any more items. Then it pushes the completion event to the <code>to_list()</code> which then pushes the <code>List</code> to the <code>Subscriber</code>. Then <code>to_list()</code> calls <code>on_completed()</code> up to the <code>Subscriber</code> <em>after</em> the <code>List</code> is emitted.</p>
<p>Use <code>do_action()</code> when you need to “peek” inside any point in the <code>Observable</code> chain, either for debugging or quickly call actions at that point.</p>
<h2><a id="3__Subjects_2046"></a>3 - Subjects</h2>
<p>Another way to create an <code>Observable</code> is by declaring a <code>Subject</code>. A <code>Subject</code> is both an <code>Observable</code> and <code>Observer</code>, and you can call its <code>Observer</code> functions to push items through it and up to any Subscribers at any time.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx.subjects <span class="hljs-keyword">import</span> Subject

subject = Subject()

subject.filter(<span class="hljs-keyword">lambda</span> i: i &lt; <span class="hljs-number">100</span>) \
    .map(<span class="hljs-keyword">lambda</span> i: i * <span class="hljs-number">1000</span>) \
    .subscribe(<span class="hljs-keyword">lambda</span> i: print(i))

subject.on_next(<span class="hljs-number">10</span>)
subject.on_next(<span class="hljs-number">50</span>)
subject.on_next(<span class="hljs-number">105</span>)
subject.on_next(<span class="hljs-number">87</span>)

subject.on_completed()
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>10000
50000
87000
</code></pre>
<p>While they seem convenient, Subjects are often discouraged from being
 used. They can easily encourage antipatterns and are prone to abuse. 
They also are difficult to compose against and do not respect <code>subscribe_on()</code>.
 It is better to create Observables that strictly come from one defined 
source, rather than be openly mutable and have anything push items to it
 at anytime. Use Subjects with discretion.</p>
<h2><a id="4_Error_Recovery_2077"></a>4. Error Recovery</h2>
<p>There are a number of error recovery operators, but we will cover two helpful ones. Say you have an <code>Observable</code> operation that will ultimately attempt to divide by zero and therefore throw an error.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">35</span>]) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-number">5</span> / i) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(i), on_error=<span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>1.0
0.8333333333333334
2.5
division by zero
</code></pre>
<p>There are multiple ways to handle this. Of course, the best way is to be proactive and use <code>filter()</code> to hold back any <code>0</code>
 value emissions. But for the sake of example, let’s say we did not 
expect this error and we want a way to handle any errors we have not 
considered.</p>
<p>One way is to use <code>on_error_resume_next()</code> which will switch to an alternate <code>Observable</code> source in the event there is an error. This is somewhat contrived, but if we encounter an error we can switch to emitting an <code>Observable.range()</code>.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">35</span>]) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-number">5</span> / i) \
    .on_error_resume_next(Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(i), on_error=<span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>1.0
0.8333333333333334
2.5
1
2
3
4
5
6
7
8
9
10
</code></pre>
<p>It probably would be more realistic to pass an <code>Observable.empty()</code> instead to simply stop emissions once an error happens.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">35</span>]) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-number">5</span> / i) \
    .on_error_resume_next(Observable.empty()) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(i), on_error=<span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>1.0
0.8333333333333334
2.5
</code></pre>
<p>Although this is not a good example to use it, you can also use <code>retry()</code> to re-attempt subscribing to the <code>Observable</code>
 and hope the next set of emissions are successful without error. You 
typically should pass an integer argument to specify the number of retry
 attempts before it gives up and lets the error go to the <code>Subscriber</code>. If you do not, it will retry an infinite number of times.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

Observable.from_([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">35</span>]) \
    .map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-number">5</span> / i) \
    .retry(<span class="hljs-number">3</span>) \
    .subscribe(on_next=<span class="hljs-keyword">lambda</span> i: print(i), on_error=<span class="hljs-keyword">lambda</span> e: print(e))
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>1.0
0.8333333333333334
2.5
1.0
0.8333333333333334
2.5
1.0
0.8333333333333334
2.5
division by zero
</code></pre>
<p>You can also use this in combination with the <code>delay()</code> operator to hold off subscribing for a fixed time period, which can be helpful for intermittent connectivity problems.</p>
<h2><a id="5_combine_latest_2177"></a>5. combine_latest()</h2>
<p>There is one operation for merging multiple Observables together we did not cover: <code>combine_latest()</code>. It behaves much like <code>zip()</code> but will only combine the <em>latest</em>
 emissions for each source in the event one of them emits something. 
This is helpful for hot event sources especially, such as user inputs in
 a UI, where do you not care what the previous emissions are.</p>
<p>Below, we have two interval sources put in <code>combine_latest()</code>: <code>source1</code> emitting every 3 seconds and <code>source2</code> every 1 second. Notice that <code>source2</code> is going to emit a lot faster, but rather than get queued up like in <code>zip()</code> waiting for an emission from <code>source1</code>, it is going to pair with only the latest emission from <code>source1</code>. It is not going to wait for any emission to be zipped with. Conversely, when <code>source1</code> does emit something it is going to pair with the latest emission from <code>source2</code>, not wait for an emission.</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> rx <span class="hljs-keyword">import</span> Observable

source1 = Observable.interval(<span class="hljs-number">3000</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"SOURCE 1: {0}"</span>.format(i))
source2 = Observable.interval(<span class="hljs-number">1000</span>).map(<span class="hljs-keyword">lambda</span> i: <span class="hljs-string">"SOURCE 2: {0}"</span>.format(i))

Observable.combine_latest(source1, source2, <span class="hljs-keyword">lambda</span> s1,s2: <span class="hljs-string">"{0}, {1}"</span>.format(s1,s2)) \
    .subscribe(<span class="hljs-keyword">lambda</span> s: print(s))

input(<span class="hljs-string">"Press any key to quit\n"</span>)
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>Press any key to quit
SOURCE 1: 0, SOURCE 2: 1
SOURCE 1: 0, SOURCE 2: 2
SOURCE 1: 0, SOURCE 2: 3
SOURCE 1: 0, SOURCE 2: 4
SOURCE 1: 1, SOURCE 2: 4
SOURCE 1: 1, SOURCE 2: 5
SOURCE 1: 1, SOURCE 2: 6
SOURCE 1: 1, SOURCE 2: 7
SOURCE 1: 2, SOURCE 2: 7
SOURCE 1: 2, SOURCE 2: 8
SOURCE 1: 2, SOURCE 2: 9
SOURCE 1: 2, SOURCE 2: 10
SOURCE 1: 3, SOURCE 2: 10
SOURCE 1: 3, SOURCE 2: 11
SOURCE 1: 3, SOURCE 2: 12
SOURCE 1: 3, SOURCE 2: 13
</code></pre>
<p>Again, this is a helpful alternative for <code>zip()</code> if you want to emit the <em>latest combinations</em> from two or more Observables.</p>

</body></html>